
# Глобальний об'єкт

Глобальний об'єкт надає змінні та функції, доступ до яких можна отримати з бідь-якого місця в програмі. За замовчуванням глобальними об'єктами є вбудовані в саму мову або оточення змінні та функції.

В браузері глобальний об'єкт має назву `window`, в Node.js --  `global`. В інших середовищах виконання він може називатися інакше.

Нещодавно у мову було додано `globalThis`, стандартизоване ім'я для глобального об'єкту, яке повинне підтримуватись в будь-якому середовищі виконання. Але в деяких браузера `globalThis` ще не підтримується (наприклад в Edge не на Chromium), але може бути легко реалізоване за допомогою polyfill.

Надалі ми будемо використовувати `window`, припускаючи, що наше середовище буде браузером. Краще використовувати `globalThis`, якщо ваш скрипт може запускатися в інших середовищах.

Доступ до усіх властивостей глобального об'єкту можна отримати безпосередньо:

```js run
alert("Hello");
// це те саме, що й
window.alert("Hello");
```

В браузері глобальні функції та змінні, оголошені за допомогою `var` (не `let/const`!) стають властивостями глобального об'єкту:

```js run untrusted refresh
var gVar = 5;

alert(window.gVar); // 5 (стає властивістю глобального об'єкту)
```

Будь ласка, не розраховуйте на це! Така поведінка підтримується лише для сумісності і в сучасних проектах, які використовують [JavaScript модулі](info:modules) такого не ідбувається.

Цього б не відбулося, якби ми оголосили змінну за допомогою `let`:

```js run untrusted refresh
let gLet = 5;

alert(window.gLet); // undefined (не стає властивістю глобального об'єкту)
```

Якщо властивість настільки важлива, що ви хочете зробити його доступним для всієї програми, запишіть її в глобальний об'єкт напряму:

```js run
*!*
// зробити інформацію про поточного користувача глобальною для надання доступу усім скриптам
window.currentUser = {
  name: "John"
};
*/!*

// в будь-якому місці коду
alert(currentUser.name);  // John

// або, якщо ми маємо локальну змінну "currentUser"
// отримаємо її з window (безопасно!)
alert(window.currentUser.name); // John
```

При цьому зазвичай не рекомендується використовувати глобальні змінні, тому потрібно використовувати їх якомога рідше. Дизайн коду, де функція отримує вхідні значення та повертає певний результат, чистіша, менш схильна до помилок та зручніша для тестування, ніж якщо вона використовує зовнішні або глобальні змінні.

## Використання глобальних об'єктів для polyfill

Глобальні об'єкти використовуються для перевірки підтримки сучасних можливостей мови.

Наприклад, можна перевірити наявність вбудованого об'єкту `Promise` (в дуже старих браузерах він не підтримується):
```js run
if (!window.Promise) {
  alert("Ваш браузер дуууже старий!");
}
```

Якщо `Promise` не знайдено, то ми можемо створити "polyfill", тобто додати функції, які не підтримуються середовищем, але існують в сучасному стандарті:

```js run
if (!window.Promise) {
  window.Promise = ... // власна реалізація сучасної можливості мови
}
```

## Підсумок

- Глобальний об'єкт зберігає змінні, які повинні бути доступними з будь-якого місця програми.

    Він включає в себе вбудовані об'єкти (такі як `Array`) та характерні для оточення властивості (такі як `window.innerHeight` -- висота вікна в браузері).
- Глобальний об'єкт має універсальне ім'я -- `globalThis`.

    ...Але найчастіше на нього посилаються по-старому, використовуючи іменування, характерне для середовища виконання: `window` (браузери) і `global` (Node.js). Оскільки `globalThis` з'явився досить недавно, він не підтримується в браузерах IE та версіях Edge, що не використовують Chromium. Але можливо використати polyfill.
- Слід зберігати значення в глобальних об'єктах тільки тоді, коли вони є дійсно глобальними для усього нашого проекту.
- В браузерах глобальні функції та змінні, оголошені за допомогою `var` стають властивостями глобального об'єкту. Але це так лише тоді, коли ми не використовуємо [модулі](info:modules).
- Слід безпосередньо звертатися до властивостей глобального об'єкту (`window.x`) для того, щоб зробити наш код простішим для розуміння та зручнішим для його підтримки в майбутньому.
