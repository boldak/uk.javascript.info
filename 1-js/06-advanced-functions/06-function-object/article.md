
# Об'єкт функції, NFE

Як ми вже знаємо, в JavaScript функція - це значення.

Кожне значення в JavaScript має свій тип. А функція - це який тип?

В JavaScript функції - це об'єкти.

Можна уявити функцію як "об'єкт, який може робити якусь дію". Функції можна не тільки викликати, але і використовувати їх як звичайні об'єкти: додавати / видаляти властивості, передавати їх по посиланню і т.д.


## Властивість "name" 

Об'єкт функції містить кілька корисних властивостей.

Наприклад, ім'я функції нам доступно як властивість "name":

```js run
function sayHi() {
  alert("Hi");
}

alert(sayHi.name); // sayHi
```

Що досить цукаво, логіка призначення `name` розумна. Вона привласнює коректне ім'я навіть в разі, коли функція створюється без імені і тут же присвоюється, ось так:

```js run
let sayHi = function() {
  alert("Hi");
};

alert(sayHi.name); // sayHi (є ім'я!)
```

Це працює навіть в разі надання значення за замовчуванням:

```js run
function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi (працює!)
}

f();
```

У специфікації це називається "контекстне ім'я": якщо функція не має name, то JavaScript намагається визначити його з контексту.

Також імена мають і методи об'єкта:

```js run
let user = {

  sayHi() {
    // ...
  },

  sayBye: function() {
    // ...
  }

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye
```

У цьому немає ніякої магії. Буває, що коректне ім'я визначити неможливо. У таких випадках властивість name має пусте значення.

Наприклад:

```js run
// функція оголошена всередині масиву
let arr = [function() {}];

alert( arr[0].name ); // <порожня стрічка>
// тут відсутня можливість визначити ім'я, тому його немає
```

Втім, на практиці таке буває рідко, зазвичай функції мають `name`.

## Властивість "length" 

Ще одна вбудована властивість "length" містить кількість параметрів функції в її оголошенні. Наприклад:

```js run
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```

Як ми бачимо, три крапки, що означає "залишкові параметри", тут як би "не рахується"

Властивість `length` іноді використовується для [інтроспекції] (https://uk.wikipedia.org/wiki/Інтроспекція_(програмування)) у функціях, які працюють з іншими функціями.

Наприклад, в коді нижче функція `ask` приймає в якості параметрів питання` question` і довільну кількість функцій-обробників відповіді `handler`.

Коли користувач відповідає на питання, функція викликає обробники. Ми можемо передати два типи обробників:

- Функцію без аргументів, яка буде викликатися тільки в разі позитивної відповіді.
- Функцію з аргументами, яка буде викликатися в обох випадках і повертати відповідь.

Щоб викликати обробник `handler` правильно, будемо перевіряти властивість` handler.length`.

Ідея полягає в тому, щоб мати простий синтаксис обробника без аргументів для позитивних відповідей (найбільш поширений випадок), але також і можливість передавати універсальні обробники:

```js run
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

// для позитивних відповідей викликаються обидва типи обробників
// для негативних - тільки другого типу
ask("Question?", () => alert('You said yes'), result => alert(result));
```

Це окремий випадок так званого [Ad-hoc-поліморфізму] (https://uk.wikipedia.org/wiki/Ad_hoc_поліморфізм) - обробка аргументів залежно від їх типу або, як в нашому випадку - від значення `length`. Ця ідея має застосування в бібліотеках JavaScript.

## Користувацькі властивості

Ми також можемо додати свої власні властивості.

Давайте додамо властивість `counter` для відстеження загальної кількості викликів:

```js run
function sayHi() {
  alert("Hi");

  *!*
  // давайте порахуємо, скільки викликів ми зробили
  sayHi.counter++;
  */!*
}
sayHi.counter = 0; // початкове значення

sayHi(); // Hi
sayHi(); // Hi

alert( `Called ${sayHi.counter} times` ); // Викликана 2 рази
```

```warn header="Властивість не є змінною"
Властивість функції, призначена як `sayHi.counter = 0`, не оголошує * локальну змінну` counter` всередині неї. Іншими словами, властивість `counter` і змінна` let counter` - це дві незалежні речі.

Ми можемо використовувати функцію як об'єкт, зберігати в ній властивості, але вони ніяк не впливають на її виконання. Змінні - це не властивості функції і навпаки. Це два паралельні світи.
```

Іноді властивості функції можуть використовуватися замість замикань. Наприклад, ми можемо переписати функцію-лічильник з голови <info:closure>, використовуючи її властивість:

```js run
function makeCounter() {
  // замість:
  // let count = 0

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
```

Властивість `count` тепер зберігається прямо в функції, а не в її зовнішньому лексичному оточенні.

Це гірше або краще, ніж використовувати замикання?

Основна відмінність в тому, що якщо значення `count` живе у зовнішній змінній, то воно не доступно для зовнішнього коду. Змінити його можуть тільки вкладені функції. А якщо воно присвоєно як властивість функції, то ми можемо його отримати:

```js run
function makeCounter() {

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();

*!*
counter.count = 10;
alert( counter() ); // 10
*/!*
```

Тому вибір реалізації залежить від наших цілей.

## Named Function Expression

Named Function Expression, або NFE -- це термін для Function Expressions який має ім'я.

Наприклад, давайте об'явимо Function Expression:

```js
let sayHi = function(who) {
  alert(`Hello, ${who}`);
};
```

І присвоїмо йому ім'я:

```js
let sayHi = function *!*func*/!*(who) {
  alert(`Hello, ${who}`);
};
```

Чого ми тут досягли? Яка мета цього додаткового імені `func`?

Для початку зауважимо, що функція все ще задана як Function Expression. Додавання `" func "` після `function` не перетворює оголошення в Function Declaration, тому що воно все ще є частиною виразу присвоювання.

Додавання такого імені нічого не ламає.

Функція все ще доступна як `sayHi ()`:

```js run
let sayHi = function *!*func*/!*(who) {
  alert(`Hello, ${who}`);
};

sayHi("John"); // Hello, John
```

Є дві важливі особливості імені `func`, заради якого воно дається:

1. Воно дозволяє функції посилатися на себе ж.
2. Воно не доступна за межами функції.

Наприклад, нижче функція `sayHi` викликає себе з` "Guest" `, якщо не переданий параметр` who`:

```js run
let sayHi = function *!*func*/!*(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    func("Guest"); // використовує func, щоб знову викликати себе ж
*/!*
  }
};

sayHi(); // Hello, Guest

// А ось так - не працює:
func(); // Помилка, func не визначена (недоступна поза функцією)
```

Чому ми використовуємо `func`? Чому просто не використовувати `sayHi` для вкладеного виклику?

Взагалі, зазвичай ми можемо вчинити так:

```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    sayHi("Guest");
*/!*
  }
};
```

Однак, у цього коду є проблема, яка полягає в тому, що значення `sayHi` може бути змінено. Функція може бути присвоєна іншій змінній, і тоді код почне видавати помилки:

```js run
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    sayHi("Guest"); // Помилка: sayHi не є функцією
*/!*
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Помилка, вкладений виклик sayHi більше не працює!
```

Так відбувається, тому що функція бере `sayHi` з зовнішнього лексичного оточення. Так як локальна змінна `sayHi` відсутня, використовується зовнішня. І на момент виклику ця зовнішня `sayHi` дорівнює` null`.

Необов'язкове ім'я, яке можна вставити в Function Expression, якраз і покликане вирішувати такого роду проблеми.

Давайте використаємо його, щоб виправити наш код:

```js run
let sayHi = function *!*func*/!*(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    func("Guest"); // Тепер все у порядку
*/!*
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest (вкладений виклик працює)
```

Тепер все працює, тому що ім'я `" func "` локальне і знаходиться всередині функції. Тепер воно взято не зовні (і недоступно звідти). Специфікація гарантує, що воно завжди буде посилатися на поточну функцію.

Зовнішній код все ще містить змінні `sayHi` і` welcome`, але тепер `func` - це" внутрішнє ім'я функції ", таким чином вона може викликати себе зсередини.

```smart header =" Це не працює з Function Declaration "
Трюк з "внутрішнім" ім'ям, описаний вище, працює тільки для Function Expression і *не* працює для Function Declaration. Для Function Declaration синтаксис не передбачає можливість оголосити додаткове "внутрішнє" ім'я.

Найчастіше, коли нам потрібно надійне "внутрішнє" ім'я, варто переписати Function Declaration на Named Function Expression.
```

## Підсумок

Функції -- це об'єкти.

Їх властивості:

- `name` - ім'я функції. Зазвичай береться з оголошення функції, але якщо там немає - JavaScript намагається зрозуміти його з контексту.
- `length` - кількість аргументів на оголошенні функції. Три крапки ("залишкові параметри") не рахуються.

Якщо функція оголошена як Function Expression (поза основним потоком коду) і має ім'я, тоді це називається Named Function Expression. Це ім'я може бути використано для посилання на себе ж, для рекурсивних викликів і т.п.

Також функції можуть містити додаткові властивості. Багато відомих JavaScript-бібліотек майстерно використовують цю можливість.

Вони створюють "основну" функцію і додають безліч "допоміжних" функцій всередину першої. Наприклад, бібліотека [jQuery] (https://jquery.com) створює функцію з ім'ям `$`. Бібліотека [lodash] (https://lodash.com) створює функцію `_`, а потім додає в неї` _.clone`, `_.keyBy` і інші властивості (щоб дізнатися про неї більше див. [Документацію] ( https://lodash.com/docs)). Вони роблять це, щоб зменшити засмічення глобального простору імен за допомогою того, що одна бібліотека надає тільки одну глобальну змінну, зменшуючи ймовірність конфлікту імен.


Таким чином, функція може не тільки робити щось сама по собі, але також і надавати корисну функціональність через свої властивості.
