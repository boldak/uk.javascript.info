# Декоратори та передача, виклик/застосування

JavaScript надає надзвичайну гнучкість при роботі з функціями. Вони можуть бути використані як об'єкти, і зараз ми побачисо як *передавати* виклики між ними і *декорувати* їх.

## Прозоре кешування

Наприклад ми маємо функцію `slow(x)` яка має велику нагрузку на процессор, але її результати стабільні. Іншими словами, для однакового `x` воно завжди повертає один і той же результат.

Якщо функція викликається часто, то ми захочему кешувати(запам'ятати) результати щоб уникнути втрату додаткового часу на переобчислення. 

Замість того, щоб добавити цю функціональність в `slow()` ми создамо функцію-обгортку, яка добавляє кешування. І, як можга побачити, існує багато переваг від цього.

Ось код і пояснення:

```js run
function slow(x) {
  // може бути велика нагрузка на процессор
  alert(`Визвано з ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {    // якщо є таке значення х в кеші
      return cache.get(x); // прочитати результат з нього
    }

    let result = func(x);  // в іншому випадку визвати функцію

    cache.set(x, result);  // и занести в кеш(запам'ятати) результат
    return result;
  };
}

slow = cachingDecorator(slow);

alert( slow(1) ); // slow(1) збережений у кеш
alert( "Знову: " + slow(1) ); // так само

alert( slow(2) ); // slow(2) збережений у кеш
alert( "Знову: " + slow(2) ); // так само, як і попередня строка
```

В коді зверху `cachingDecorator` є *декоратор*: спеціальна функція, яка бере іншу функцію і змінює її поведінку. 

Ідея полягає в тому зо ми можемо викликати `cachingDecorator` для будь якої функції, і воно поверне обгортку кешування. Це чудово, тому що ми можемо мати багато функцій які використовують це, і все, що ми повинні зробити - застосувати `cachingDecorator` до них.

Зберігаючи кешинг і основну функцію окремо ми можемо зберегти основний код простішим.

Результат `cachingDecorator(func)` - є "обгортка": `function(x)` яка "обертає" виклик `func(x)` в логіку кешування:

![](decorator-makecaching-wrapper.svg)

Із зовнішнього коду, обернута `slow` функція все ще робить те саме. Воно лише отримало аспект кешування до своєї поведінки.

Для підсумку, існує декілька переваг використання окремого `cachingDecorator` замість зміни коду самої функції `slow`:

- `cachingDecorator` можна використовувати нескінченну кількість разів. Ми можемо застосовувати її до іншої функції.
- Логіка кешування окрема, вона не збільшує складність самої `slow` (якщо така існує).
- Ми можемо комбінувати декілка декораторів, якщо потрібно (інші декоратори послідують).

## Використання "func.call" для контексту

Кешувальний декоратор, який був згаданий вище, не може бути використанним для роботи з обьектнимими методами

Наприклад, в коді знизу  `worker.slow()` зупиняє свою роботу після декорації:

```js run
// ми зробимо worker.slow робити кешинг
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    // тут велика нагрузка на процессор  
    alert("Викликана з " + x);
    return x * this.someMethod(); // (*)
  }
};

// так само як і код раніше
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
*!*
    let result = func(x); // (**)
*/!*
    cache.set(x, result);
    return result;
  };
}

alert( worker.slow(1) ); // оригінальний метод працює

worker.slow = cachingDecorator(worker.slow); // розпочнемо кешування

*!*
alert( worker.slow(2) ); // Упс, помилка: Неможливо прочитати, власність 'someMethod' невизначена
*/!*
```

Помилка виникаж в строці `(*)` яка намагається отримати доступ до `this.someMethod`, але невдачно. Можете побачити чому?

Причина в тому, що обгортка викликає оригінальну функція як `func(x)` в строці `(**)`. І, коли так викликана, функція отримує `this = undefined`.

Ми б наблюдали схожий результат, якщо намагались запустити:

```js
let func = worker.slow;
func(2);
```

Отже, обгортка передає виклик до оригінального методу, але без контексту `this`. Звідси і помилка.

Давайте її виправимо.

Існує спеціальнр вбудована функція метод [func.call(context, ...args)](mdn:js/Function/call) яка дозволяє викликати функцію, явно встановлюючи `this`.

Синтаксис:

```js
func.call(context, arg1, arg2, ...)
```

Воно запускає `func` забезпечуючи перший аргумент як `this`, та наступні як аргументи. 

Проще кажучи, ці два виклики роблять майже те саме:
```js
func(1, 2, 3);
func.call(obj, 1, 2, 3)
```

Вони оба викликають `func` з аргументами `1`, `2` and `3`. Єдина різниця - те, що `func.call` також встановлює `this` до `obj`.

Як приклад, в коді знизу ми визиваємо `sayHi` в контексті різних об'єктів: `sayHi.call(user)` запускає `sayHi` забезпечуючи `this=user`, и встановлює наступну строку як `this=admin`:

```js run
function sayHi() {
  alert(this.name);
}

let user = { name: "Джон" };
let admin = { name: "Адмін" };

// використовуйте виклик для передачі різних об'єктів як "this"
sayHi.call( user ); // Джон
sayHi.call( admin ); // Адмін
```

І тут ми використовуємо `call` для виклику `say` с даним контекстом і фразою(phrase):


```js run
function say(phrase) {
  alert(this.name + ': ' + phrase);
}

let user = { name: "Джон" };

// user становиться this, і "Привіт" становиться першим аргументом
say.call( user, "Привіт" ); // Джон: Привіт
```

В нашому випадку, ми можемо використати `call` в обгортці для передачі контексту до оригінальної функції

```js run
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert("Визвано з " + x);
    return x * this.someMethod(); // (*)
  }
};

function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
*!*
    let result = func.call(this, x); // "this" передається зараз правильно
*/!*
    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow); // зараз перейдемо до кешування

alert( worker.slow(2) ); // працює
alert( worker.slow(2) ); // працює, не викликає оригінал(кешування)
```

Зараз все добре.

Для уточнення, давайте подивимось більш детально як `this` передається далі:

1. Після декорації, `worker.slow` зараз обгортка `function (x) { ... }`.
2. Отже коли `worker.slow(2)` виконаний, обгортка отримує `2` як аргумент і `this=worker` (це об'єкт перед крапкою).
3. Всередині обгортки, предпологаючи, що результат ще не скешований, `func.call(this, x)` передає поточне `this` (`=worker`) і поточний аргумент (`=2`) до оригінального методу.

## Перехід до багатьох аргументів з "func.apply"

Зараз зробими `cachingDecorator` ще більш універсальним. Перед цим, воно працювало лише з одно-аргументними функціями.

Як зараз кешувати багато-аргументний `worker.slow` метод?

```js
let worker = {
  slow(min, max) {
    return min + max; // можливе зависання процессору
  }
};

// повнні пам'ятати одно-аргументні виклики
worker.slow = cachingDecorator(worker.slow);
```

До цього, для одного аргументу `x` ми могли лише використати `cache.set(x, result)` щоб зберегти результат і `cache.get(x)` для його витягування. Але зараз нам потрібно запам'ятати результат для *комбінаціх аргументів* `(min,max)`. Рідна `Map` бере одне число лише як ключ.

Існує багато виходів із проблеми:

1. Розробити нову (або використати сторонні) схожі на map структури данних, які більш універсальні і дозволяє використння багато-ключовості.
2. Використовувати вкладенні мапи: `cache.set(min)` буде `Map` яка зберігає пару `(max, result)`. І ми можемо отримати `result` як `cache.get(min).get(max)`.
3. З'єднати два значення в одне. В нашому особливому випадку ми можемо використати строку `"min,max"` як `Map` ключ. Для гнучкості, ми можемо дозволити забезпечення *хешингової функції* для декоратору, яка знає як зробити одне значення із багатьох.

Для багатьох практичних апплікацій, 3-й варіант підходить краще, тому його і будемо використовувати.

Також нам потрібно замінити `func.call(this, x)` з `func.call(this, ...arguments)`, для передачі всіх аргументів до обернутої функції-виклику, не тільки першого.

Ось більш сильний `cachingDecorator`:

```js run
let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
*!*
    let key = hash(arguments); // (*)
*/!*
    if (cache.has(key)) {
      return cache.get(key);
    }

*!*
    let result = func.call(this, ...arguments); // (**)
*/!*

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3, 5) ); // works
alert( "Again " + worker.slow(3, 5) ); // same (cached)
```

Зараз це працює з будь-якою кількістю аргументів (вле хеш функція також потрібно поправити, щоб дозволити будь-яку кількість аргументів. Інтересни метод зміни - знизу).

Існує дві зміни:

- В строці `(*)` воно викликає `hash` щоб создати єдиний ключ із `arguments`. Тут ми використовуємо просту "joining" функцію приєднання, яка перетворює аргументи `(3, 5)` в ключ `"3,5"`. Більш склідні випадки можуть потребувати інші функції хешування.
- Потім `(**)` використовує `func.call(this, ...arguments)` для передачі контекст і всі аргументи, які має обгортка (не тільки перший) до оригінальної функції.

Замість `func.call(this, ...arguments)` ми можемо використати `func.apply(this, arguments)`.

Синтаксис вбудованого методу [func.apply](mdn:js/Function/apply):

```js
func.apply(context, args)
```

Він запускає `func` встановлюючи `this=context` і використовуючи обьєки схожий на строку `args` як список аргументів.

Єдина різниця в синтаксисі між `call` і `apply` це те, що `call` очікує список аргументів, поки `apply` бере строковий обьєкт з собою.

Отже ці два виклики майже однакові:

```js
func.call(context, ...args); // передає строку як список с широким синтаксисом
func.apply(context, args);   // так само як виклик використання
```

Є лише невелика відмінність:

- Широкий синтаксис `...` дозволяє предавати allows to pass *ітерабельні* `args` як список до `call`.
- `apply` приймає лише *строкові* `args`.

Отже, ці виклики доповняють один одного. Де ми очікуємо ітератор, `call` працює, Де ми очікуємо строку, `apply` працює.

І для об'єктів, які і ітерабельні, і строкові, як справжня строка, ми можемо використовувати будь який із них, але `apply` напевно буде швидшу, тому що більшість JavaScript движків внутрішньо оптимізує його краще.

Передача всіх аргументів разом з контекстом до інших функцій називається передачою виклику.

Ось найпростіша його форма:

```js
let wrapper = function() {
  return func.apply(this, arguments);
};
```

Коли зовнішній код викликає таку обгортку, то вона не відрізняється від виклику оригінальної функції `func`.

## Запозиченя методу [#method-borrowing]

Зараз зробимо одне невелике покращення в функції хешування:

```js
function hash(args) {
  return args[0] + ',' + args[1];
}
```

Зараз, воно лише працює лише на 2 аргументи. Було б краще, якщот воно могло склеювати будь-яку кількість `args`.

Природнє рішення булоб використати метод [arr.join](mdn:js/Array/join) method:

```js
function hash(args) {
  return args.join();
}
```

...На превеликий жаль, це не спрацює. Тому що ма визиваємо `hash(arguments)` і `arguments` обьєкт - одночасно ітерабельний і строковий, але не реальний масив.

Тому виклик `join` на це не спрацює, як ми можемо побачити знизу:

```js run
function hash() {
*!*
  alert( arguments.join() ); // Помилка: arguments.join не є функцією
*/!*
}

hash(1, 2);
```

Але, є легкий шлях використати масив join:

```js run
function hash() {
*!*
  alert( [].join.call(arguments) ); // 1,2
*/!*
}

hash(1, 2);
```

Цей трюк називається *запозичення методу*.

Ми беремо (позичаємо) метод join з регулярного масиву (`[].join`) і використовуємо `[].join.call` для запуску його в контексті `arguments`.

Чому це працює?

Це тому що, внутрішній алгоритм рідного методу `arr.join(glue)` дуже простий.

Взятий із специфікації майже "як є":

1. Позволити `glue` бути першим аргументом чи, якщо нема аргументів, тоді кома `","`.
2. Позволити `result` бути пустою строкою.
3. Збільшити `this[0]` до `result`.
4. Збільшити `glue` і `this[1]`.
5. Збільшити `glue` і `this[2]`.
6. ...Робити так до тих пір, поки `this.length` значення не склеються.
7. Повернути `result`.

Отже, технічно воно бере `this` і приєднує `this[0]`, `this[1]` ...і так далі разом. Це спеціиально написано так, щоб для будь якого строкового значення `this` (не случайність, багато методів мають таку практику). Тому це працює також з `this=arguments`.

## Деоратири та власності функції

Зазвичай це безопасно замінити функцію або метод з декорованим, із викюченням однієї деталі. Якщо оригінал функції мав власності в ньому, як `func.calledCount` або схоже, тоді декорований не буде працювати. Тому що це - обгортка. Тому потрібно бути обережним, якщо користуватися ним.

Наприклад у прикладі зверху якщо функція `slow` мала якісь власності в собі, тоді `cachingDecorator(slow)` - обгортка без них.

Деякі декоратори можеть забезпечувати свої власні влсаності. Наприклад декоратор може порахувати скільки разів функція була визвана або скільки часу це заняло, і вивести цю інформацію шляхом власностей обгортки.

Існує шлях, щоб створити декоратори які сберігають доступ до власностей функції, але це потребує використання спеціального проксі `Proxy` об'єкту щоб обернути функцію. Ми обговоримо це пізніше в статті <info:proxy#proxy-apply>.

## Підсумок

*Декоратор* - обгортка навколо функції, яка змінює її поведінку. Основна роль досі виконується функцією. 

Декоратори можуть вважатися як "особливості" або "аспекти", які можеть бути додані до функції. Ми можемо додати одну або багато. І це все без зміни коду!

Щоб здійснити `cachingDecorator`, ми вивчили методи:

- [func.call(context, arg1, arg2...)](mdn:js/Function/call) -- виклики `func` з наданими контекстами і аргументами.
- [func.apply(context, args)](mdn:js/Function/apply) -- виклики `func` передачі `context` як `this` і строкові `args` в список аргументів.

Родова *передача визову* часто зроблена з застосуванням `apply`:

```js
let wrapper = function() {
  return original.apply(this, arguments);
};
```

Ми також бачили приклад *запозичення методу*, коли ми взяли метод із об'єкту і  `визвали` його в контексті з іншим об'єктом. Це доволі часто, щоб брати масивні методи і застосовували до них аргументи `arguments`. Альтернатива до цього - використати всі інші параметричні об'єкти, ніби це є справжній масив.

Існує багато декораторів в просторі інтернету. Перевір як добре ті засвоїв їх, виконуючи завдання із цієї частини.
