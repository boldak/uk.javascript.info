
# Синтаксис "new Function"

Існує ще один варіант як оголошувати функції. Він використовується вкрай рідко, але іноді іншого рішення не знайти.

## Синтаксис

Синтаксис для оголошення функції:

```js
let func = new Function ([arg1, arg2, ...argN], functionBody);
```

Функція створюється з заданими аргументами `arg1...argN` і тілом `functionBody`.

Це простіше зрозуміти на конкретному прикладі. Тут оголошена функція з двома аргументами:

```js run
let sum = new Function('a', 'b', 'return a + b');

alert( sum(1, 2) ); // 3
```

А ось функція без аргументів, в цьому випадку досить вказати тільки тіло:

```js run
let sayHi = new Function('alert("Hello")');

sayHi(); // Hello
```

Головна відмінність від інших способів оголошення функції, які були розглянуті раніше, полягає в тому, що функція створюється повністю  з рядка, переданого під час виконання.

Всі попередні оголошення вимагали від нас, програмістів, писати оголошення функції в скрипті.

Але `new Function` дозволяє перетворити будь-який рядок в функцію. Наприклад, можна отримати нову функцію з сервера і потім виконати її:

```js
let str = ... receive the code from a server dynamically ...

let func = new Function(str);
func();
```

Це використовується в дуже специфічних випадках, наприклад, коли ми отримуємо код з сервера для динамічної компіляції функції з шаблону, в складних веб-додатках.

## Замикання

Зазвичай функція запам'ятовує, де народилася, в спеціальній властивості `[[Environment]]`. Це посилання на лексичне оточення (Lexical Environment) в якому вона створена (ми розбирали це в главі <info:closure>).

Але коли функція створюється з використанням `new Function`, в її `[[Environment]]` записується посилання не на зовнішнє лексичне оточення, в якому вона була створена, а на глобальне. 

Тому така функція має доступ тільки до глобальних змінних.

```js run
function getFunc() {
  let value = "test";

*!*
  let func = new Function('alert(value)');
*/!*

  return func;
}

getFunc()(); // помилка: value не визначене
```

Порівняємо це з звичайним оголошенням:

```js run
function getFunc() {
  let value = "test";

*!*
  let func = function() { alert(value); };
*/!*

  return func;
}

getFunc()(); // *!*"test"*/!*, з лексичного оточення функції getFunc
```

Ця особливість `new Function` виглядає дивно, але виявляється дуже корисною на практиці.

Уявіть, що потрібно створити функцію з рядка. Код цієї функції невідомий під час написання скрипта (тому не використовуємо звичайні функції), а буде визначений тільки в процесі виконання. Ми можемо отримати код з сервера або з іншого ресурсу.

Наша нова функція повинна взаємодіяти з основним скриптом.

А що якби вона мала доступ до зовнішніх змінних?

Проблема в тому, що перед відправкою JavaScript-коду на реальні працюючі проекти код стискається за допомогою *minifier* -- спеціальної програми, яка зменшує розмір коду, видаляючи коментарі, зайві прогалини, і, що найголовніше, локальним змінним даються укорочені імена.

Наприклад, якщо в функції оголошується змінна `let userName`, то мініфікатор змінює її на `let a` (Або іншу букву, якщо вона не зайнята) і змінює її всюди. Зазвичай так робити безпечно, тому що змінна є локальною, і ніхто зовні не має до неї доступ. І всередині функції мініфікатор замінює кожну її згадку. Мініфікатори досить розумні. Вони не просто здійснюють "тупий" пошук-заміну, вони аналізують структуру коду, і тому нічого не ламається.

Так що якщо б навіть `new Function` і мала доступ до зовнішніх змінним, вона не змогла б знайти перейменовану  `userName`.

**Якби `new Function` мала доступ до зовнішніх змінних, при цьому були б проблеми з мініфікаторами.**

Крім того, такий код мав би гіршу архітектуру і був би схильнішим до помилок.

Щоб передати щось в функцію, створену як `new Function`, можна використовувати її аргументи.

## Підсумок

Синтаксис:

```js
let func = new Function ([arg1, arg2, ...argN], functionBody);
```

З історичних причин аргументи також можуть бути оголошені через кому в одному рядку.

Ці три оголошення нижче еквівалентні:

```js
new Function('a', 'b', 'return a + b'); // стандартний синтаксис
new Function('a,b', 'return a + b'); // через кому в одному рядку
new Function('a , b', 'return a + b'); // через кому з пробілами в одному рядку
```

Функції, оголошені через `new Function`, мають `[[Environment]]` що посилається на глобальне лексичне оточення, а не на батьківське. Тому вони не можуть використовувати зовнішні локальні змінні. Але це дуже добре, тому що страхує нас від помилок. Параметри що передані явно - є набагато кращим архітектурним рішенням, яке не викликає проблем у мініфікаторів.
