# Планування: setTimeout та setInterval

Ми можемо викликати функцію не прямо зараз, а пізніше, через заданий момент часу. Це називається "планування виклику".

Для цього є два методи:

- `setTimeout` викликає функцію одиноразово через певний інтервал часу.
- `setInterval` викликає функцію регулярно, повторюючи виклик через певний інтервал часу.

Ці методи не є частиною специфікації JavaScript. Але більшість середовищ виконання JS-коду мають внутрішній планувальник і надають доступ до цих методів. Зокрема, вони підтримуються у всіх браузерах і Node.js.

## setTimeout

Синтаксис:

```js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```

Параметри:

`func|code`
: Функція або рядок коду для виконання.
Зазвичай це функція. З історичних причин можна передати і рядок коду, але це не рекомендується.

`delay`
: Затримка до виконання, у мілісекундах (1000 мс = 1 секунда), за замовчуванням = 0.

`arg1`, `arg2`...
: Аргументи для функції (не підтримується в IE9-)

Наприклад, цей код викликає `sayHi()` з затримкою в одну секунду:

```js run
function sayHi() {
  alert('Привіт');
}

*!*
setTimeout(sayHi, 1000);
*/!*
```

З аргументами:

```js run
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}

*!*
setTimeout(sayHi, 1000, "Привіт", "Джон"); // Привіт, Джон
*/!*
```

Якщо перший аргумент є рядком, тоді JavaScript створює з нього функцію.

Тому це теж буде працювати:

```js run no-beautify
setTimeout("alert('Привіт')", 1000);
```

Але використання строки все ж не рекомендується. Краще використовувати функцію зі стрілкою, як тут:

```js run no-beautify
setTimeout(() => alert('Привіт'), 1000);
```

````smart header = "Передавання функції без запускання"
Зверніть увагу: розробники іноді помиляються, додаючи дужки `()` після функції:

```js
// помилка!
setTimeout(sayHi(), 1000);
```
Це не працює тому, що `setTimeout` очікує посилання на функцію. Тут `sayHi ()` запускає виконання функції. Результат виконання відправиться в `setTimeout`. У цьому нашому випадку результатом виконання `sayHi ()` є `undefined` (бо функція нічого не повертає). Тому нічого не планується.
````

### Скасування через clearTimeout

Виклик `setTimeout` повертає "ідентифікатор таймара" `timerId`, який можна використовувати для скасування виконання.

Синтаксис для скасування:

```js
let timerId = setTimeout(...);
clearTimeout(timerId);
```

У коді нижче ми плануємо виклик функції, а потім скасовуємо його (передумали). Як результат нічого не відбувається:

```js run no-beautify
let timerId = setTimeout(() => alert("ніколи не відбудиться"), 1000);
alert(timerId); // ідентифікатор таймера

clearTimeout(timerId);
alert(timerId); // той самий ідентифікатор (не перетворюється на null після скасування)
```

Як ми бачимо з виводу `alert`, у браузері ідентифікатор таймера є числом. У інших середовищах це може бути щось ще. Наприклад, Node.js повертає об'єкт таймера з додатковими методами.

Повторюся, немає єдиної специфікації для цих методів, тому така поведінка є нормальною.

Для браузерів таймери описані в [розділі таймерів] (https://www.w3.org/TR/html5/webappapis.html#timers) стандарту HTML5.

## setInterval

Метод `setInterval` має однаковий синтаксис з `setTimeout`:

```js
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
```

Усі аргументи мають таке ж значення. Але відмінність цього методу від `setTimeout` у тому, що функція запускається не один раз, а періодично, через вказаний інтервал часу.

Щоб зупинити подальше виконання функції, необхідно викликати `clearInterval (timerId)`.

Наступний приклад виводить повідомлення кожні 2 секунди. Через 5 секунд вивод припиняється:

```js run
// повторюється кожні 2 секунди
let timerId = setInterval(() => alert('tick'), 2000);

// через 5 секунд вивод припиниться
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
```

```smart header="Враховуємо час і при показу `alert`"
У більшості браузерів, включаючи Chrome і Firefox, внутрішній лічильник продовжує цокати під час показу `alert/confirm/prompt`.
 Якщо запустити код вгорі і почекати виконання `alert` вікна декілька секунд, тоді наступний `alert` буде показано одразу коли ви закриєте попередній. Тоді інтервал між повідомленнями 'alerts' буде коротшим за 2 секунди.
```

## Рекурсивний setTimeout

Є два способи запускати щось регулярно.

Один з них `setInterval`. Іншим є рекурсивний `setTimeout`. наприклад:

```js
/** замість
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('tick');
*!*
  timerId = setTimeout(tick, 2000); // (*)
*/!*
}, 2000);
```

Метод `setTimeout` вгорі планує наступний виклик одразу після закінчення поточного `(*)`.

Рекурсивний `setTimeout` - більш гнучкий ніж` setInterval`. З його допомогою наступний виклик може бути заданий по-різному в залежності від результата попереднього.

Наприклад, необхідно написати сервіс, який відправляє запит для отримання даних на сервер кожні 5 секунд, але якщо сервер перевантажений, необхідно збільшити інтервал запитів до 10, 20, 40 секунд ...

Ось псевдокод:

```js
let delay = 5000;

let timerId = setTimeout(function request() {
  ...надсилає запит...

  if (помилка запиту через перезавантаження сервера) {
    // збільшуємо інтервал наступного запиту
    delay *= 2;
  }

  timerId = setTimeout(request, delay);

}, delay);
```


А якщо функції, які ми плануємо, ресурсомісткі і вимагають часу, то ми можемо виміряти час, витрачений на виконання, і спланувати наступний виклик раніше або пізніше.

**Рекурсивний `setTimeout` дозволяє задати затримку між виконаннями більш точно, ніж` setInterval`.**

Порівняємо два фрагмента коду. Перший використовує `setInterval`:

```js
let i = 1;
setInterval(function() {
  func(i++);
}, 100);
```

Другий використовує рекурсивний `setTimeout`:

```js
let i = 1;
setTimeout(function run() {
  func(i++);
  setTimeout(run, 100);
}, 100);
```

У `setInterval`планувальник інтервалу запускає `func(i++)` кожні 100 мс:

![](setinterval-interval.svg)

Звернули увагу?

**Реальна затримка між викликом `func` за допомогою `setInterval` меньше, ніж вказано у коді!**

Це нормально, тому що час, витрачений на виконання `func`, використовує частину заданого інтервалу часу.

Цілком можливо, що виконання `func` буде довше, ніж ми очікували, і займе більше 100 мс.

У даному випадку движок чекає закінчення виконання `func`, потім перевіряє планувальник і, якщо час минув, *негайно* запускає його знову.

У крайньому випадку, якщо функція завжди виконується довше, ніж затримка `delay`, то виклики будуть виконуватися без затримок взагалі.

Нижче представлено зображення, що показує процес роботи рекурсивного `setTimeout`:

![](settimeout-interval.svg)

**Рекурсивний `setTimeout`гарантує фіксовану затримку (тут 100 мс).**

Це тому, що новий виклик заплановано після попереднього.

````smart header="Збір мусора та колбек setInterval/setTimeout"
Коли функція передається в `setInterval/setTimeout`, на неї створюється і зберігається в планувальнику внутрішнє посилання. Це захищає функцію від потрапляння в збирач сміття, навіть якщо на неї немає інших посилань.

```Js
// функція залишається в пам'яті до тих пір, поки планувальник звертається до неї
setTimeout(function() {...}, 100);
```

Для `setInterval` функція залишається в пам'яті поки не буде викликано `clearInterval`.

Також є побічний ефект. Функція посилається на зовнішнє лексичне оточення, тому поки вона існує, зовнішні змінні існують теж. Вони можуть займати більше пам'яті, ніж сама функція. Тому, якщо регулярний виклик функції більше не потрібен, краще скасувати його, навіть якщо функція дуже маленька.
````

## setTimeout з нульовою затримкою

Є особливий варіант використання: `setTimeout (func, 0)` або просто `setTimeout (func)`.

Це планує виклик `func` настільки швидко, наскільки це можливо. Але надасть права викликати функцію тільки після завершення виконання поточного коду.

Так виклик функції буде запланований відразу після виконання поточного коду.

Наприклад, цей код виводить "Привіт", а потім одразу "Мир":

```js run
setTimeout(() => alert("Мир"));

alert("Привіт");
```

Перший рядок "поміщає виклик у календар через 0 мс". Але планувальник "перевірить календар" тільки після того, як поточний код завершиться. Тому `"Привіт"` виводиться першим, а `"Мир"` -- після нього.

Існують більш просунуті випадки використання нульової затримки в браузерах, які ми розглянемо в розділі <info:event-loop>.

````smart header = "Нульова затримка по факту не є нульовою (у браузері)"
У браузері є обмеження на те, як часто внутрішні лічильники можуть виконуватися. В [стандарті HTML5] (https://www.w3.org/TR/html5/webappapis.html#timers) говориться: "після п'яти вкладених таймерів інтервал повинен становити не менше чотирьох мілісекунд.".

Продемонструємо це в прикладі нижче. Виклик `setTimeout` повторно викликає себе з затримкою 0 мс. Кожен виклик запам'ятовує реальний час попереднього виклику в масиві `times`. Яка реальна затримка? подивимося:

```js run
let start = Date.now();
let times = [];

setTimeout(function run() {
  times.push(Date.now() - start); // запам'ятовуємо затримку попереднього виклику

  if (start + 100 < Date.now()) alert(times); // показуємо затримку після 100 мс
  else setTimeout(run); // інакше перепланування
});

// приклад виводу:
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100
```

Перший таймер запускається одразу (як і вказано в специфікації), а потім ми бачимо `9, 15, 20, 24 ...`. Починається обов'язкова затримка 4+ мс.

Те ж саме відбувається при використанні `setInterval` замість` setTimeout`: `setInterval (f)` запускає `f` кілька разів з нульовою затримкою, а потім -- із затримкою 4+ мс.

Це обмеження існує давно, багато скрипти покладаються на нього, тому воно зберігається з історичних причин.

Цього обмеження немає в серверному JavaScript. Там є й інші способи планування негайних асинхронних завдань. Наприклад, [setImmediate] (https://nodejs.org/api/timers.html) для Node.js. Так що це обмеження стосується лише браузерів.
````

## Підсумки

- Методи `setTimeout(func, delay, ...args)` та `setInterval(func, delay, ...args)` дозволяють нам запускати `func` одноразово/регулярно після `delay` мілісекунд.
- Щоб відмінити виконання, нам слід скористатись `clearTimeout/clearInterval` зі значенням, яке повертає `setTimeout/setInterval`.
- Рекурсивний використання `setTimeout` є більш гнучкою альтернативою `setInterval`. Він дає нам можливість більш точно задати інтервал *між* викликами.
- Нульова затримка за допомогою `setTimeout(func, 0)` (те ж саме що і `setTimeout(func)`) використовується для планування викликів "настільки швидко, наскільки це можливо, але завершення виконання поточного коду".
- Браузер обмежує мінімальну затримку між п'ятьма або більше вкладеними викликами `setTimeout` або `setInterval` (після п'ятого виклику) до 4 мс. Це відбувається з історичних причин.

Звернемо увагу, що всі методи планування не *гарантують* точну затримку.

Наприклад, таймер в браузері може сповільнюватися з багатьох причин:
- Перевантажені процесор.
- Вкладка браузера працює у фоновому режимі.
- Робота ноутбука від акумулятора.

Все це може збільшувати мінімальний інтервал спрацьовування таймера (мінімальну затримку) до 300 мс або навіть 1000 мс в залежності від браузера і налаштувань продуктивності ОС.
