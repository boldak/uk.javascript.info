# Залишкові параметри і синтакс розширення

Багато вбудованих функцій JavaScript підтримують довільну кількість аргументів. 

Наприклад:

- `Math.max(arg1, arg2, ..., argN)` -- повертає найбільший з аргументів.
- `Object.assign(dest, src1, ..., srcN)` -- копіює властивості з `src1..N` в `dest`.
- ...і т.д.

У цьому розділі ми розберемо як робити те саме з нашими власними функціями і як передавати масиви до них у якості параметрів.

## Залишкові параметри `...`

Функцію можна викликати використовуючи будь-яку кількість аргументів, незалежно від того, як вона визначена.

Як-от тут:
```js run
function sum(a, b) {
  return a + b;
}

alert( sum(1, 2, 3, 4, 5) );
```

Помилки через "перевищену" кількість аргументів не буде. Але, звісно, зрештою лише перші два з них будуть використані.

Інші параметри можуть бути включені до визначення функції за допомогою `...`, за якими слідує ім'я масиву, що їх містить. Крапки буквально означають "зібрати решту параметрів в масив".

До прикладу, щоб помістити усі аргументи в масив `args`:

```js run
function sumAll(...args) { // args -- ім'я масиву
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

alert( sumAll(1) ); // 1
alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6
```

Ми можемо взяти перші змінні в якості параметрів, а решту зібрати в масив.

Ось два аргументи беремо в якості змінних, а решту поміщаємо в масив `titles`:

```js run
function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Julius Caesar

  // решта -- до масиву titles
  // i.e. titles = ["Consul", "Imperator"]
  alert( titles[0] ); // Consul
  alert( titles[1] ); // Imperator
  alert( titles.length ); // 2
}

showName("Julius", "Caesar", "Consul", "Imperator");
```

````warn header="The rest parameters must be at the end"
Залишкові параметри збирають усі інші аргументи, тому немає сенсу писати що-небудь після них. Це спровокує помилку:

```js
function f(arg1, ...rest, arg2) { // arg2 after ...rest ?!
  // error
}
```

`...rest` повинен завжди стояти останнім.
````

## Змінна "arguments"

Існує також спеціальний масив-подібний об'єкт під назвою `arguments`, який містить усі аргументи по індексу.

Наприклад:

```js run
function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // ітерабельний
  // for(let arg of arguments) alert(arg);
}

// shows: 2, Julius, Caesar
showName("Julius", "Caesar");

// shows: 1, Ilya, undefined (no second argument)
showName("Ilya");
```

Раніше залишкових параметрів у мові не існувало, і використання `arguments` було єдиним способом отримати всі аргументи функції. І це досі працює, ми можемо побачити це у старому коді.

Але мінус полягає в тому, що хоча `arguments` є одначасно масив-подібним об'єктом (псевдомасивом) та ітерабельним, це не масив. Він не підтримує жоден метод для масивів, тому не можна викликати, наприклад, `arguments.map(...)`.

Також, він завжди містить усі аргументи. Ми не можемо частково їх захопити, як ми робили із залишковими параметрами.

Тому коли нам це необхідно, залишкові члени стануть у пригоді.

````smart header="Стрілочні функції `\"arguments\"`"
Якщо ми отримаємо об'єкт `arguments` із стрілочної функції, вона візьме їх із зовнішньої функції.

Приклад:

```js run
function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1); // 1
```

Як Ви можете пам'ятати, стрілочні функції не мають власного `this`. Зараз ми знаємо, що також немає свого об'єкта `arguments`.
````


## Spread syntax [#spread-syntax]

Тільки що ми бачили, як отримати масив із списку параметрів.

Але іноді нам необхідно зробити навпаки.

До прикладу, існує вбудована функція [Math.max](mdn:js/Math/max), що повертає найбільше число зі списку:

```js run
alert( Math.max(3, 5, 1) ); // 5
```

Тепер, скажімо, ми маємо масив `[3, 5, 1]`. Як у цьому випадку викликати `Math.max`?

Передати його "як є" неможливо, адже `Math.max` потребує числовий список, а не один масив:

```js run
let arr = [3, 5, 1];

*!*
alert( Math.max(arr) ); // NaN
*/!*
```

І, звісно, ми не можемо вручну вводити числа як `Math.max(arr[0], arr[1], arr[2])`, бо ми не знаємо, скільки їх. Коли наш скрипт виконується, їх може бути багато, а може не бути взагало. І це не круто.

Тут *оператор розширення* і приходить на допомогу. Він виглядає подібно до решти параметрів, так само використовуючи `...`, але роблячи протилежне.

Коли `...arr` використовується у виклику функції, він "розширює" ітерабельний об'єкт `arr` до списку аргументів.

Для `Math.max`:

```js run
let arr = [3, 5, 1];

alert( Math.max(...arr) ); // 5 (оператор розкриває масив у список аргументів)
```

Так само можна передати декілька ітерабельних об'єктів:

```js run
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(...arr1, ...arr2) ); // 8
```

Можемо навіть поєднувати оператори розширення зі звичайними значеннями:


```js run
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
```

Також оператор розширення можна використати для злиття масивів:

```js run
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

*!*
let merged = [0, ...arr, 2, ...arr2];
*/!*

alert(merged); // 0,3,5,1,2,8,9,15 (0, далі arr, потім 2, нарешті arr2)
```

У прикладах зверху ми використали масив для демонстрації оператору розширення, але він працює для будь-яких ітерабельних об'єктів.

Наприклад, тут ми використовуємо його для перетворення рядка в масив симовлів:

```js run
let str = "Hello";

alert( [...str] ); // H,e,l,l,o
```

Оператор розвирення використовує ітератори для зібрання елемени, так само як `for..of`.

Отже, для рядка, `for..of` повертає символи, і `...str` стає `"H","e","l","l","o"`. Список символів передається на ініціалізатор масиву `[...str]`.

Для цієї конкретної задачі ми можемо також використати `Array.from`, адже він конвертує ітерабельний (як-от рядок) в масив:

```js run
let str = "Hello";

// Array.from конвертує ітерабельний об'єкт в масив
alert( Array.from(str) ); // H,e,l,l,o
```

Результат такий самий, як для `[...str]`.

Але є невелика відмінність між `Array.from(obj)` і `[...obj]`:

- `Array.from` застосовується як для масив-подібних об'єктів, так і для ітерабельних.
- Оператор розширення працює лише з ітерабельними об'єктами.

Отже, для завдання перетворення чогось у масив `Array.from` є, мабуть, найбільш універсальним.


## Отримати нову копію об'єкту/масиву

Згадайте, коли ми говорили про `Object.assign()` [раніше](https://javascript.info/object#cloning-and-merging-object-assign)?

Це можливо зробити і з оператором розширення!

```js run
let arr = [1, 2, 3];
let arrCopy = [...arr]; // розширюємо масив до списку параметрів
                        // далі поміщаємо результат в новий масив

// масиви мають однаковий вміст?
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// масиви рівні?
alert(arr === arrCopy); // false (not same reference)

// зміна початкового масиву не змінює копію:
arr.push(4);
alert(arr); // 1, 2, 3, 4
alert(arrCopy); // 1, 2, 3
```

Зауважте, що можливо зробити те саме для створення копії об'єкта:

```js run
let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; // розширюємо об'єкт до списку параметрів
                          // далі повертаємо результат в новий об'єкт

// об'єкти мають однаковий вміст?
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// об'єкти рівні?
alert(obj === objCopy); // false (not same reference)

// зміна початкового об'єкту не змінює копію:
obj.d = 4;
alert(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
alert(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
```

Це спосіб копіювання об'єкту є значно коротшим за `let objCopy = Object.assign({}, obj);` або для масивів `let arrCopy = Object.assign([], arr);`, тож краще використовувати його коли це можливо.


## Підсумок

Коли ми бачемо `"..."` в коді, це означає залишкові параметри або оператор розширення.

Є простий спосіб їх розрізнити:

- Коли `...` в кінці списку параметрів функції -- це "залишкові параметри". Решта "невказаних" параметрів збираються в масив.
- Коли `...` розташовується у виклику функції або деінде -- це "оператор розширення". Він перетворює масив у список.

Шаблони застосування:

- Залишкові параметри використовуються для створення функцій, що приймають будь-яку кількість аргументів.
- Оператор розширення використовується для передачі масиву у функції, що зазвичай потребують списку аргументів.

Разом вони дозволяють з легкістю переключатися між списком та масивом параметрів.

Усі аргументи виклику функції також доступні у "старому стилі": масив-подібному ітерабельному об'єкті (або псевдомасиві).
