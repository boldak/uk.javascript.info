
# Застаріле ключове слово"var"

```smart header="Ця стаття призначена для розуміння старих скриптів"
Інформація в цій статті корисна для розуміння старих скриптів.
Це не те як ми пишемо новий код
```

У першому розділі про [змінні](info:variables), ми згадали три способи оголошення змінних:

1. `let`
2. `const`
3. `var`

`let` і `const` поводяться однаково з точки зору лексичних середовищ.

Але `var` це зовсім інший звір, який бере свій початок з дуже давніх часів. Зазвичай він не використовується в сучасних скриптах, але все ще може ховатися в старих.

Якщо в даний момент ви не працюєте з подібними скриптами, ви можете пропустити або відкласти прочитання цього розділу, проте, є шанс, що ви зіткнетеся з `var` в майбутньому.

На перший погляд, `var` поводиться так само, як і `let`. Наприклад, оголошення змінної:

```js run
function sayHi() {
  var phrase = "Привіт"; // локальна змінна, "var" замість "let"

  alert(phrase); // Привіт
}

sayHi();

alert(phrase); // Помилка: phrase не знайдена
```

...але відмінності таки є.

## Для "var" немає блочної області видимості

Область видимості змінних `var` обмежується функціями, або, якщо змінна глобальна, то скриптом. Такі змінні доступні за межами блоку.

Наприклад:

```js run
if (true) {
  var test = true; // використовуємо "var" замість "let"
}

*!*
alert(test); // true, змінна існує за межами блоку if
*/!*
```

Так як `var` ігнорує блоки, ми отримуємо глобальну змінну `test`.

Якщо б ми використовували `let test` замість `var test`, тоді змінна була б доступною тільки в блоці `if`:

```js run
if (true) {
  let test = true; // використовуємо "let"
}

*!*
alert(test); // Помилка: test не знайдена
*/!*
```

Так само і для циклів: `var` не може бути блочною чи локальною у циклі:

```js
for (var i = 0; i < 10; i++) {
  // ...
}

*!*
alert(i); // 10, змінна "i" доступна поза межами циклу, так як вона глобальна
*/!*
```

Якщо блок коду знаходиться в функції, то `var` стає локальною змінною в цій функції:

```js run
function sayHi() {
  if (true) {
    var phrase = "Привіт";
  }

  alert(phrase); // працює
}

sayHi();
alert(phrase); // Помилка: phrase не знайдена
```

Як ми бачимо, `var` виходить за межі `if`, `for` чи інших блоків коду. Це відбувається, тому що на зорі розвитку JavaScript блоки коду не мали лексичного оточення. Саме тому `var` пережиток минулого.

## "var" обробляються на початку запуску функції

Оголошення змінних `var` обробляються на початку виконання функції (або запуску скрипта, якщо змінна є глобальною).

Іншими словами, змінні `var` вважаються оголошеними з самого початку виконання функції незалежно від того, в якому місці функції реально знаходяться їх оголошення (за умови, що вони не перебувають у вкладеній функції).

Тобто цей код:

```js run
function sayHi() {
  phrase = "Привіт";

  alert(phrase);

*!*
  var phrase;
*/!*
}
sayHi();
```

...Технічно повністю еквівалентний наступному (оголошення змінної `var phrase` переміщено в початок функції):

```js run
function sayHi() {
*!*
  var phrase;
*/!*

  phrase = "Привіт";

  alert(phrase);
}
sayHi();
```

...І навіть коду нижче (як ви пам'ятаєте, блокова область видимості ігнорується):

```js run
function sayHi() {
  phrase = "Привіт"; // (*)

  *!*
  if (false) {
    var phrase;
  }
  */!*

  alert(phrase);
}
sayHi();
```

Така поведінка називається "hoisting" (спливання, підняття), тому що всі оголошення змінних `var` "спливають" в самий верх функції.

Отже, у прикладі вище `if (false)` умова ніколи не виконається, але це не важливо. Змінна `var` "спливає" на початок функції, тобто в момент присвоєння значення `(*)` змінна вже існує.

**Оголошення змінних "спливають", але присвоєння значень - немає.**

Найпростіше продемонструвати це на прикладі:

```js run
function sayHi() {
  alert(phrase);  

*!*
  var phrase = "Привіт";
*/!*
}

sayHi();
```

Рядок `var phrase = "Hello"` складається з двух дій:

1. Оголошення змінної `var`
2. Присвоєння значення змінної `=`.

Оголошення змінної обробляється на початку виконання функції ("спливає"), проте присвоєння значення завжди відбувається в тому рядку коду, де воно зазначено. Тобто код виконується за наступним сценарієм:

```js run
function sayHi() {
*!*
  var phrase; // оголошення змінної спрацьовуе на початку...
*/!*

  alert(phrase); // undefined

*!*
  phrase = "Привіт"; // ...присвоєння - в момент, коли виповниться даний рядок коду.
*/!*
}

sayHi();
```

Оскільки всі оголошення змінних `var` dобробляються на початку функції, ми можемо посилатися на них в будь-якому місці. Однак, змінні мають значення `undefined` до рядка з присвоєнням значення.

В обох прикладах вище виклик `alert` відбувався без помилки, тому що змінна `phrase` вже існувала. Але її значення ще не було присвоєно, тому ми отримували `undefined`.

### IIFE

Оскільки в минулому існував лише `var`, і він не має видимості на рівні блоків, програмісти винайшли спосіб його емуляції. Те, що вони зробили, називалося "immediately-invoked function expressions" (скорочено IIFE).

Це не те, що ми повинні сьогодні використовувати, але ви можете знайти це у старих скриптах.

IIFE виглядає так:

```js run
(function() {

  let message = "Привіт";

  alert(message); // Привіт

})();
```

Тут вираз функції створюється і відразу викликається. Таким чином, код виконується відразу ж і має власні закриті змінні.

Вираз функції укладено в круглі дужки `(function {...})`, тому що коли JavaScript зустрічає «function» в основному потоці коду, він розуміє його як початок оголошення функції. Але оголошення функції повинно мати ім'я, тому код такого типу видасть помилку:

```js run
// Спробуйте оголосити і негайно викликати функцію
function() { // <-- Помилка: для операторів функцій слід вказати ім'я функції

  let message = "Привіт";

  alert(message); // Привіт

}();
```

Навіть якщо ми скажемо: «Добре, давайте додамо ім'я», це не спрацює, оскільки JavaScript не дозволяє викликати оголошення функцій відразу:

```js run
// синтаксична помилка через дужки нижче
function go() {

}(); // <-- не може негайно викликати оголошення функції
```

Таким чином, круглі дужки навколо функції - це ніби пастка, що показує JavaScript, що функція створюється в контексті іншого виразу, і, отже, цей вислів функції: їй не потрібно ім'я і вона може бути викликана негайно.

Крім дужок, існують інші способи повідомити JavaScript, що ми маємо на увазі вираз функції:

```js run
// Шляхи створення IIFE

(function() {
  alert("Дужки навколо функції");
}*!*)*/!*();

(function() {
  alert("Дужки навколо всього");
}()*!*)*/!*;

*!*!*/!*function() {
  alert("Побітовий оператор NOT запускає вираз");
}();

*!*+*/!*function() {
  alert("Унарний плюс запускає вираз");
}();
```

У всіх вищезгаданих випадках ми оголошуємо вираз функції і запускаємо його негайно. Відзначимо ще раз: наразі немає причин писати такий код.

## Підсумки

Існує 2 основні відмінності `var` від `let/const`:

1. Змінні `var` не мають блокової області видимості, вони обмежені, як мінімум, тілом функції.
2. Оголошення (ініціалізація) змінних `var` проводиться на початку виконання функції (або скрипта для глобальних змінних).

Є ще одна невелика відмінність, що стосується глобального об'єкту, ми розглянемо її в наступному розділі.

Всі ці відмінності роблять `var` гіршою за `let` у більшості випадків. Блокова область видимості - це зручно. Саме через це багато років тому `let` і `const` були введені в стандарт і зараз є основним способом оголошення змінних.
