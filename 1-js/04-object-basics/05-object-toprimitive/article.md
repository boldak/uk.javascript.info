# Перетворення об'єктів в примітиви

Що станеться, якщо додати два об'єкти `obj1 + obj2`, відняти один з іншого ` obj1 - obj2` або вивести їх на екран, скориставшись `alert (obj)`?

В цьому випадку об'єкти спочатку автоматично перетворюються в примітиви, а потім виконується операція.

У розділі <info:type-conversions> ми бачили правила для чисельних, строкових і логічних перетворень. Але обділили увагою об'єкти. Тепер, оскільки ми вже знаємо про методи об'єктів і символи, можна виправити це упущення.

1. Всі об'єкти в логічному контексті є `true`. Існують лише їх чисельні і рядкові перетворення.
2. Чисельні перетворення відбуваються, коли ми віднімаємо об'єкти або виконуємо математичні операції. Наприклад, об'єкти `Date` (ми розглянемо їх в статті <info:date>) можуть відніматися, і результатом ` date1 - date2` буде часовий відрізок між двома датами.
3. Що стосується строкових перетворень - вони зазвичай відбуваються, коли ми виводимо об'єкт `alert (obj)`, а також в інших випадках, коли об'єкт використовується як рядок.

## Перетворення до примітивів

Ми можемо точно налаштовувати рядкові і чисельні перетворення, використовуючи спеціальні методи об'єкту.

Існують три варіанти перетворень ("три хінти"), описані в [специфікації](https://tc39.github.io/ecma262/#sec-toprimitive):

`" String "`
: Для перетворення об'єкта до рядка, коли операція очікує отримати рядок, наприклад `alert`:

```js
// вивід
alert (obj);

// використовуємо об'єкт в якості імені властивості
anotherObj [obj] = 123;
```

`" Number "`
: Для перетворення об'єкта до числа, в разі математичних операцій:

```js
// явне перетворення
let num = Number (obj);

// математичне (виключаючи бінарний оператор "+")
let n = + obj; // унарний плюс
let delta = date1 - date2;

// порівняння більше / менше
let greater = user1> user2;
```

`" default "`
: Відбувається рідко, коли оператор "не впевнений", який тип очікувати.

    Наприклад, бінарний плюс `+` може працювати з обома типами: рядками (об'єднувати їх) і числами (додавати). Таким чином, і ті, і інші будуть обчислюватися. Або коли відбувається порівняння об'єктів за допомогою несуворої рівності `==` з рядком, числом або символом, і неясно, яке перетворення має бути виконано.

```js
// бінарний плюс
let total = car1 + car2;

// obj == string / number / symbol
if (user == 1) {...};
```

    Оператор більше / менше `<>` також може працювати як з рядками, так і з числами. Однак, з історичних причин він використовує хінт "number", а не "default".

    На практиці все вбудовані об'єкти, виключаючи `Date` (ми познайомимося з ним трохи пізніше), реалізують` "default" `перетворення тим же способом, що і` "number" `. І нам слід робити так само.

Зверніть увагу, що існують лише три варіанти хінтів. Все настільки просто. Не існує хінту зі значенням "boolean" (всі об'єкти є `true` в логічному контексті) або будь-яких ще. І якщо ми вважаємо `" default "` і `" number "` однаковими, як більшість вбудованих об'єктів, то залишаються лише два варіанти перетворень.

** У процесі перетворення двигун JavaScript намагається знайти і викликати три наступних методи об'єкту: **

1. Викликає `obj [Symbol.toPrimitive] (hint)` - метод з символьним ключем `Symbol.toPrimitive` (системний символ), якщо такий метод існує, і передає йому хінт.
2. Інакше, якщо хінт дорівнює `" string "`
    - намагається викликати `obj.toString ()`, а якщо його немає, то `obj.valueOf ()`, якщо він існує.
3. У разі, якщо хінт дорівнює `" number "` або `" default "`
    - намагається викликати `obj.valueOf ()`, а якщо його немає, то `obj.toString ()`, якщо він існує.

## Symbol.toPrimitive

Почнемо з універсального підходу - символу `Symbol.toPrimitive`: метод з такою назвою (якщо є) використовується для всіх перетворень:

```Js
obj [Symbol.toPrimitive] = function (hint) {
  // повинен повернути примітивне значення
  // hint дорівнює чомусь одному з: "string", "number" або "default"
};
```

Для прикладу використовуємо його в реалізації об'єкта `user`:

```Js run
let user = {
  name: "John",
  money 1000,

  [Symbol.toPrimitive] (hint) {
    alert ( `hint: $ {hint}`);
    return hint == "string"? `{Name:" $ {this.name} "}`: this.money;
  }
};

// демонстрація результатів перетворень:
alert (user); // hint: string -> {name: "John"}
alert (+ user); // hint: number -> 1000
alert (user + 500); // hint: default -> 1500
```

Як ми бачимо з коду, `user` перетворюється або в інформативний рядок, або в грошовий рахунок в залежності від значення хінта. Єдиний метод `user [Symbol.toPrimitive]` зміг обробити всі випадки перетворень.

## Методи toString / valueOf

Методи `toString` і ` valueOf` беруть свой початок з давніх часів. Смороду не символ, так як в тій годину сімволів Ще не існувало, а просто звічайні методи об'єктів Із строкового іменамі. Смороду Надаються "застарілій" способ реализации Перетворення об'єктів.


## Методи toString / valueOf

Методи `toString` і `valueOf` беруть свій початок з давніх часів. Вони не символи, так як в той час символів ще не існувало, а просто звичайні методи об'єктів із строковими іменами. Вони надають "застарілий" спосіб реалізації перетворень об'єктів.

Якщо немає методу `Symbol.toPrimitive`, двигун JavaScript намагається знайти ці методи і викликати їх наступним чином:

- `toString -> valueOf` для хінта зі значенням" string ".
- `valueOf -> toString` - в іншому випадку.

Для прикладу, використовуємо їх у реалізації все того ж об'єкта `user`. Відтворимо його поведінку комбінацією методів `toString` і `valueOf`:

```Js run
let user = {
  name: "John",
  money 1000,

  // для хінта рівного "string"
  toString () {
    return `{name:" $ {this.name} "}`;
  },

  // для хінта рівного "number" або "default"
  valueOf () {
    return this.money;
  }

};

alert (user); // toString -> {name: "John"}
alert (+ user); // valueOf -> 1000
alert (user + 500); // valueOf -> 1500
```

Як бачимо, вийшла та ж поведінка, що і в попередньому прикладі з `Symbol.toPrimitive`.

Досить часто ми хочемо описати одне "універсальне" перетворення об'єкта до примітиву для всіх ситуацій. Для цього достатньо створити один `toString`:

```Js run
let user = {
  name: "John",

  toString () {
    return this.name;
  }
};

alert (user); // toString -> John
alert (user + 500); // toString -> John500
```

За відсутності `Symbol.toPrimitive` і` valueOf`, `toString` обробить всі випадки перетворень до примітивів.


## Типи, які повертаються

Важливо розуміти, що всі описані методи для перетворень об'єктів не зобов'язані повертати саме необхідний "хінтом" тип примітиву.

Немає обов'язкової вимоги, щоб `toString ()` повертав саме рядок, або щоб метод `Symbol.toPrimitive` повертав саме число для хінта" number ".

**Єдина обов'язкова вимога: методи повинні повертати примітив, а не об'єкт.**

```smart header ="Історична довідка"
З історичних причин, якщо `toString` або` valueOf` поверне об'єкт, то помилки не буде, але таке значення буде проігноровано (як якби методу взагалі не існувало).

Метод `Symbol.toPrimitive`, навпаки, *зобов'язаний* повертати примітив, інакше нічого не вийде.
```

## Наступні операції

Операція, яка ініціювала перетворення, отримує примітив і потім продовжує роботу з ним, виробляючи подальші перетворення, якщо це необхідно.

наприклад:

- Математичні операції, виключаючи бінарний плюс, перетворять примітив до числа:

```Js run
    let obj = {
      // toString обробляє всі перетворення в разі відсутності інших методів
      toString () {
        return "2";
      }
    };

    alert (obj * 2); // 4, об'єкт був перетворений до примітиву "2", потім множення зробило його числом
```

- Бінарний плюс `+` в аналогічному випадку додасть рядки:

```Js run
    let obj = {
      toString () {
        return "2";
      }
    };

    alert (obj + 2); // 22 (перетворення до примітиву повернуло рядок => конкатенація)
```

## Підсумок

Перетворення об'єктів в примітиви викликається автоматично багатьма вбудованими функціями і операторами, які очікують примітив як аргумент.

Існує всього 3 типи перетворень (хінтів):
- `" string "` (для `alert` та інших операцій, яким потрібен рядок)
- `" number "` (для математичних операцій)
- `" default "` (для деяких операцій)

У специфікації явно зазначено, який хінт повинен використовувати кожен оператор. І існує зовсім небагато операторів, які не знають, що очікувати, і використовують хінт зі значенням `" default "`. Зазвичай для вбудованих об'єктів хінт `" default "` обробляється так само, як `" number "`. Таким чином, останні два дуже часто об'єднують разом.

Алгоритм перетворень до примітивів наступний:

1. Спочатку викликається метод `obj [Symbol.toPrimitive] (hint)`, якщо він існує.
2. Інакше, якщо хінт дорівнює `" string "`
    - відбувається спроба викликати `obj.toString ()`, потім `obj.valueOf ()`, дивлячись що є.
3. Інакше, якщо хінт дорівнює `" number "` або `" default "`
    - відбувається спроба викликати `obj.valueOf ()`, потім `obj.toString ()`, дивлячись що є.

На практиці досить часто досить реалізувати тільки `obj.toString ()` як "універсальний" метод для всіх типів перетворень, який повертає "читаєме" уявлення об'єкта, достатнє для логування або налагодження.
