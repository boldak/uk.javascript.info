# Масиви

Об'єкти дозволяють зберігати дані із строковими ключами. Це чудово.

Але досить часто ми розуміємо, що нам необхідна *впорядкована колекція* даних, в якій присутні 1-й, 2-й, 3-й елементи і т.д. Наприклад, вона знадобиться нам для зберігання списку чогось: користувачів, товарів, елементів HTML і т.д.

В цьому випадку використовувати об'єкт незручно, так як він не надає методів управління порядком елементів. Ми не можемо вставити нову властивість "між" вже існуючими. Об'єкти просто не призначені для цих цілей.

Для зберігання впорядкованих колекцій існує особлива структура даних, яка називається масив, `Array`.

## Оголошення

Існує два варіанти синтаксису для створення порожнього масиву:

```js
let arr = new Array();
let arr = [];
```

Практично завжди використовується другий варіант синтаксису. У дужках ми можемо вказати початкові значення елементів:

```js
let fruits = ["Яблуко", "Апельсин", "Слива"];
```

Елементи масиву нумеруються, починаючи з нуля.

Ми можемо отримати елемент, вказавши його номер у квадратних дужках:

```js run
let fruits = ["Яблуко", "Апельсин", "Слива"];

alert( fruits[0] ); // Яблуко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива
```

Ми можемо замінити елемент:

```js
fruits[2] = 'Груша'; // тепер ["Яблуко", "Апельсн", "Груша"]
```

...Або додати новий до існуючого масиву:

```js
fruits[3] = 'Лемон'; // тепер ["Яблуко", "Апельсин", "Груша", "Лемон"]
```

Загальну кільксть елементів у масиві повертає його властивість `length`:

```js run
let fruits = ["Яблуко", "Апельсин", "Слива"];

alert( fruits.length ); // 3
```

Щоб вивести весь масив використовуваться `alert`.

```js run
let fruits = ["Яблуко", "Апельсин", "Слива"];

alert( fruits ); // Яблуко, Апельсин, Слива
```

Масив може зберігати елементи будь-якого типу.

Наприклад:

```js run no-beautify
// різні типи значень
let arr = [ 'Яблуко', { name: 'Джон' }, true, function() { alert('привіт'); } ];

// отримати об'єкт за індексом 1 та показати його властивість name
alert( arr[1].name ); // Джон

// отримати функцію за індексом 3 та запустити її
arr[3](); // привіт
```


````smart header="Висяча кома"
Список елементів масиву, як і список властивостей об'єкту, може завершуватись комою:
```js
let fruits = [
  "Яблуко",
  "Апельсин",
  "Слива"*!*,*/!*
];
```

"Висяча кома" спрощує додавання та видалення елементів, так як всі рядки об'єкта стають однаковими.
````


## Методи pop/push, shift/unshift

[Черга](https://uk.wikipedia.org/wiki/%D0%A7%D0%B5%D1%80%D0%B3%D0%B0_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%B8%D1%85)) є одинією з найпоширеніших варіантів застосування масиву. В області комп'ютерних наук так називається впорядкована колекція елементів, що підтримує дві операції:

- `push` додає елемент у кінець.
- `shift` забирає(видаляє) елемент з початку, зсунувши чергу, таким чином другий елемент стає першим.

![](queue.svg)

Масиви підтримують обидві операції.

На практиці така необхідність виникає дуже часто. Наприклад, черга повідомлень, які треба показати на екрані.

Існує й інший варіант застосування масивів -- структура даних, називана [стек](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA).

Він підтримує дві операції:

- `push` додає елемент у кінець.
- `pop` забирає елемент з кінця.

Таким чином, нові елементи завжди додаються або забираються з "кінця".

Прикладом стека зазвичай служить колода карт: нові карти кладуться наверх і беруться теж зверху:

![](stack.svg)

Для стеку останні додані елементи забираються першими. Ця властивість називається LIFO (англ. Last-In-First-Out). Аналогічна властивість для черги називається FIFO (англ. First-In-First-Out).

Масиви в JavaScript можуть працювати і як черга, і як стек. Ми можемо додавати / видаляти елементи як на початку, так і в кінеці масиву.

У комп'ютерних науках структура даних, що робить це можливим, називається [двобічна черга](https://uk.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B1%D1%96%D1%87%D0%BD%D0%B0_%D1%87%D0%B5%D1%80%D0%B3%D0%B0).

**Методи для роботи з кінцем масиву:**

`pop`
: Забирає(видаляє) останній елемент з масиву та повертає його:

    ```js run
    let fruits = ["Яблуко", "Апельсин", "Груша"];

    alert( fruits.pop() ); // видаляє "Груша" та виводе його

    alert( fruits ); // Яблуко, Апельсин
    ```

`push`
: Додає елемент у кінець масиву:

    ```js run
    let fruits = ["Яблуко", "Апельсин"];

    fruits.push("Груша");

    alert( fruits ); // Яблуко, Апельсин, Груша
    ```

    Використання `fruits.push(...)` рівнозначний `fruits[fruits.length] = ...`.

**Методидля роботи з початком масиву:**

`shift`
: Забирає(видаляє) перший елемент з масиву та повертає його:

    ```js
    let fruits = ["Яблуко", "Апельсин", "Груша"];

    alert( fruits.shift() ); // видаляє "Яблуко" та виводе його

    alert( fruits ); // Апельсин, Груша
    ```

`unshift`
: Додає елемент у початок масиву:

    ```js
    let fruits = ["Апельсин", "Груша"];

    fruits.unshift('Яблуко');

    alert( fruits ); // Яблуко, Апельсин, Груша
    ```

Методи `push` та `unshift` також можуть додати одразу декілька елементів:

```js run
let fruits = ["Яблуко"];

fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");

// ["Ананас", "Лимон", "Яблуко", "Апельсин", "Груша"]
alert( fruits );
```

## Внутрішній устрій масиву

Масив -- це особливий вид об'єкту. Квадратні дужки, які використовуються для того, щоб отримати доступ до властивості `arr [0]` -- це по суті звичайний синтаксис доступу по ключу, як `obj [key]`. Тут в ролі ` obj` у нас `arr`, а в якості ключа -- числовий індекс.

Масиви розширюють об'єкти, так як передбачають спеціальні методи для роботи з впорядкованими колекціями даних, а також властивість `length`. Але в основі все одно лежить об'єкт.

Слід пам'ятати, що в JavaScript існує 7 основних типів даних. Масив є об'єктом і, отже, веде себе як об'єкт.

Наприклад, копіюється за посиланням:

```js run
let fruits = ["Банан"]

let arr = fruits; // копіювання за посиланням (дві змінні посилаються на один масив)

alert( arr === fruits ); // true

arr.push("Груша"); // зміна масиву за посиланням

alert( fruits ); // Банан, Груша -- тепер 2 елементи
```

...Але що робить масиви дійсно особливими -- це їхнє внутрішнє представлення. Движок JavaScript намагається зберігати елементи масиву в безперервній області пам'яті, один за іншим, так, як це показано на ілюстраціях до цього розділу. Існують і інші способи оптимізації, завдяки яким масиви працюють дуже швидко.

Але всі вони втратять ефективність, якщо ми перестанемо працювати з масивом як з "впорядкованої колекцією даних" і почнемо використовувати його як звичайний об'єкт.

Наприклад, технічно ми можемо зробити наступне:

```js
let fruits = []; // створюємо масив

fruits[99999] = 5; // створюємо властивість з індексом набагато більшим його довжини

fruits.age = 25; // створюємо властивість з довільним ім'ям
```

Це можливо, тому що в основі масиву лежить об'єкт. Ми можемо створити йому будь-які властивості.

Але движок зрозуміє, що ми працюємо з масивом, як зі звичайним об'єктом. Способи оптимізації, використовувані для масивів, у цьому випадку не підходять. Тому тут не буде їхньої користі.

Варіанти неправильного застосування масиву:

- Додавання нечислової властивості, наприклад: `arr.test = 5`.
- Створення "дірок", наприклад: додавання `arr [0]`, потім `arr [1000]` (між ними нічого немає).
- Заповнення масиву в зворотному порядку, наприклад: `arr [1000]`, `arr [999]` і т.д.

Масив слід вважати особливою структурою, що дозволяє працювати з *впорядкованими даними*. Для цього масиви надають спеціальні методи. Масиви ретельно налаштовані в движках JavaScript для роботи з однотипними впорядкованими даними. Тому, будь ласка, використовуйте їх саме в таких випадках. Якщо вам потрібні довільні ключі, цілком можливо, краще підійде звичайний об'єкт `{}`.

## Ефективність

Методи `push/pop`виконуються швидко, а методи `shift/unshift` повільні.

![](array-speed.svg)

Чому працювати з кінцем масиву швидше, ніж з його початком? Давайте подивимося, що відбувається під час виконання:

```js
fruits.shift(); // забирає 1 елемент з початку
```

Не достатньо просто взяти та видалити елемент з індексом `0`. Також інші елементи повинні змінити свої індекси.

Операція `shift` повинна виконати 3 дії:

1. Видалити елемент з індексом `0`.
2. Зсунути всі елементи вліво, заново пронумерувати їх, замінивши індекси `1` на `0`, `2` на `1` і т. д.
3. Оновити властивість `length`.

![](array-shift.svg)

**Чим більше елементів у масиві, тим більше часу потрібно для того, щоб їх перемістити, більше операцій з пам'яттю.**

Те ж саме відбувається з методом `unshift`: щоб додати елемент в початок масиву, потрібно спочатку зрушити існуючі елементи вправо, збільшуючи їх індекси.

А що ж з `push / pop`? Їм не потрібно нічого переміщати. Щоб забрати елемент в кінці масиву, метод `pop` очищає індекс і зменшує значення` length`.

Дії при операції `pop`:

```js
fruits.pop(); // забирає 1 елемент з кінця
```

![](array-pop.svg)

**Метод `pop` не повинен переміщувати інші елементи тому, що вони не повинні змінювати свій індекс. Тому він набагато швидший.**

Те ж саме відбувається з методом `push`.

## Перебір елементів

Одним з найстаріших способів перебору елементів масиву є цикл `for` по цифровим індексам:

```js run
let arr = ["Яблуко", "Апельсин", "Груша"];

*!*
for (let i = 0; i < arr.length; i++) {
*/!*
  alert( arr[i] );
}
```

Але для масивів можливий і інший варіант циклу, `for..of`:

```js run
let fruits = ["Яблуко", "Апельсин", "Слива"];

// перебір елементів масиву
for (let fruit of fruits) {
  alert( fruit );
}
```

Цикл `for..of` не дає доступу до номеру поточного елемента, а тільки до його значення. Але в більшості випадків цього достатньо. До того ж це більш коротко.

Технічно, так як масив є об'єктом, можна використовувати і варіант `for..in`:

```js run
let arr = ["Яблуко", "Апельсин", "Груша"];

*!*
for (let key in arr) {
*/!*
  alert( arr[key] ); // Яблуко, Апельсин, Груша
}
```

Але насправді це - погана ідея. Існують приховані недоліки цього способу:

1. Цикл `for..in` виконує перебір *всіх властивостей* об'єкту, а не тільки цифрових.

    У браузері та інших програмних середовищах також існують так звані "псевдомасиви" -- об'єкти, які *виглядають, як масив*. Тобто у них є властивість `length` і індекси, але вони також можуть мати додаткові нечислові властивості і методи, які нам зазвичай не потрібні. Проте, цикл `for..in` їх виведе. Тому, якщо нам доводиться мати справу з псевдомасиви, такі "зайві" властивості можуть стати проблемою.

2. Цикл `for..in` оптимізований під довільні об'єкти, а не під масиви. Тому він у 10-100 разів повільніше (але він досі досить швидкий). Збільшення швидкості виконання може мати значення тільки при виникненні вузьких місць. Але ми все ж повинні представляти різницю.

Загалом, не слід використовувати цикл `for..in` для масивів.


## Трохи про "length"

Властивість `length` автоматично оновлюється при зміні масиву. Якщо бути точними, це не кількість елементів масиву, а найбільший цифровий індекс плюс один.

Наприклад, масив з єдиним елементом, що має великий індекс, повертає велику length:

```js run
let fruits = [];
fruits[123] = "Яблуко";

alert( fruits.length ); // 124
```

Зазначимо, що зазвичай не слід використовувати масиви таким чином.

Ще один цікавий факт про властивість `length` - його можна перезаписати.

Якщо ми збільшимо його вручну, нічого цікавого не станеться. Зате, якщо ми зменшимо його, масив стане коротшим. Цей процес є незворотнім, як ми можемо зрозуміти з прикладу:

```js run
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // зменшення до 2 елементу
alert( arr ); // [1, 2]

arr.length = 5; // return length back
alert( arr[3] ); // undefined: значення не відновилося
```

Таким чином, найпростіший спосіб очистити масив - це `arr.length = 0;`.

## new Array() [#new-array]

Існує ще один варіант синтаксису для створення масиву:

```js
let arr = *!*new Array*/!*("Яблуко", "Груша", "ще щось");
```

Він рідко застосовується, так як квадратні дужки `[]` коротше. Крім того, у нього є хитра особливість.

Якщо `new Array` викликається з одним аргументом, який являє собою число, він створює масив *без елементів, але із заданою довжиною*.

Давайте подивимося, як можна надати покласти собі граблі на дорогу:

```js run
let arr = new Array(2); // чи створить це масив [2] ?

alert( arr[0] ); // undefined! немає елементів.
alert( arr.length ); // length 2
```

У коді, представленому вище, у `new Array (number)` все елементи рівні `undefined`.

Щоб уникнути появи таких несподіваних ситуацій, ми зазвичай використовуємо квадратні дужки, якщо, звичайно, не знаємо точно що ми робимо.

## Багатовимірні масиви

Масиви можуть містити елементи, які теж є масивами. Це можна використовувати для створення багатовимірних масивів, наприклад, для зберігання матриць:

```js run
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, the central element
```

## toString

Масиви по-своєму реалізують метод `toString`, який повертає список елементів, розділених комами.

Наприклад:


```js run
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```

Тепер спробуємо наступне:

```js run
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```

Масиви не мають ані `Symbol.toPrimitive`, ані функціонуючого` valueOf`. Вони реалізують тільки перетворення `toString`, таким чином, тут `[]` стає пустим рядком, `[1]` стає `"1"`, а `[1,2]` стає `"1,2"`.

Коли бінарний оператор плюс `"+"` додає що-небудь до рядка, він теж перетворює це в рядок, таким чином:

```js run
alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
```

## Підсумок

Масив є особливим типок об'єкту, що підходить для роботи з впорядкованим набором елементів.

- Оголошення:

    ```js
    // square brackets (usual)
    let arr = [item1, item2...];

    // new Array (exceptionally rare)
    let arr = new Array(item1, item2...);
    ```

    Виклик `new Array(number)` створює масив з даною довжиною length, але без елементів.

- Властивість `length` відображає довжину масиву або, якщо точніше, його останній цифровий індекс плюс один. Довжина коригується автоматично методами масиву.
- Якщо ми зменшуємо `length` вручну, масив стає коротшим.

Ми можемо використовувати масив як двосторонню чергу, використовуючи такі операції:

- `push(...items)` додає `items` в кінець масиву.
- `pop ()` забирає елемент в кінці масиву і повертає його.
- `shift ()` забирає елемент на початку масиву і повертає його.
- `unshift(...items)` додає `items` в початок масиву.

Щоб пройтися по елементах масиву:
 - `for (let i = 0; i < arr.length; i++)` -- працює швидше за все, сумісний зі старими браузерами.
 - `for (let item of arr)` -- сучасний синтаксис тільки для значень елементів (до індексів немає доступу).
 - `for (let i in arr)` -- ніколи не використовуйте для масивів.

Ми повернемося до масивів і вивчимо інші методи додавання, видалення, виділення елементів і сортування масивів в розділі <info:array-methods>.
