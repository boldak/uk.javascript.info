# Методи масивів

Масиви мають безліч методів. Щоб було простіше, в цьому розділі вони розбиті на групи.

## Додавання/видалення елементів

Ми вже знаємо методи, які додають і видаляють елементи з початку або з кінця:

- `arr.push(...items)` -- додає елементи в кінець,
- `arr.pop()` -- видобуває елемент з кінця,
- `arr.shift()` -- видобуває елемент з початку,
- `arr.unshift(...items)` -- додає елементи на початок.

Ось деякі інші методи.

### splice

Як видалити елемент з масиву?

Масиви є об'єктами, тому ми можемо спробувати використати `delete`:

```js run
let arr = ["I", "go", "home"];

delete arr[1]; // видалити "go"

alert( arr[1] ); // undefined

// тепер arr = ["I",  , "home"];
alert( arr.length ); // 3
```

Елемент був видалений, але при перевірці виявляється, що масив досі має 3 елементи, можемо переконатись в цьому `arr.length == 3`.

Це природньо, бо все, що робить `delete obj.key` - це видаляє значення за ключем `key`. Подібне підходить для об'єктів, але для масивів треба, щоб елементи які залишилися зсунулися і зайняли місце що звільнилося. Ми очікуємо, що масив стане коротшим.

Тому для цього потрібно використовувати особливі методи.

Метод [arr.splice(start)](mdn:js/Array/splice) є універсальним для роботи з масивами. Він може: додавати, видаляти і замінювати елемети.

Його синтаксис:

```js
arr.splice(index[, deleteCount, elem1, ..., elemN])
```

Він починає з позиції `index`: видаляє `deleteCount` елементів і потім вставляє `elem1, ..., elemN` на їх місце. Повертає масив з видалених елементів.

Цей метод легко зрозуміти на прикладах.

Почнемо з видалення:

```js run
let arr = ["Я", "вивчаю", "JavaScript"];

*!*
arr.splice(1, 1); // з позиції 1 видалити 1 елемент
*/!*

alert( arr ); // ["Я", "JavaScript"]
```

Легко, правда? Починаючи з позиції `1` він видалив `1` елемент.

У наступному прикладі ми видалимо 3 елементи і замінимо їх двома ішими:

```js run
let arr = [*!*"Я", "вивчаю", "JavaScript",*/!* "прямо", "зараз"];

// видалити 3 перших елемента і замінити їх іншими
arr.splice(0, 3, "Давайте", "потанцюємо");

alert( arr ) // now [*!*"Давайте", "потанцюємо"*/!*, "прямо", "зараз"]
```

Тут видно, що `splice` повертає масив з видалених елементів:

```js run
let arr = [*!*"Я", "вивчаю",*/!* "JavaScript", "прямо", "зараз"];

// видалити 2 перших елемента
let removed = arr.splice(0, 2);

alert( removed ); // "Я", "вивчаю" <-- масив з видалених елементів
```

Метод `splice` також може вставляти елементи без видалення, для цього нам треба виставити `deleteCount` на `0`:

```js run
let arr = ["Я", "вивчаю", "JavaScript"];

// з позиції 2
// видалити 0 елементів
// потім вставити "складну" і "мову"
arr.splice(2, 0, "складну", "мову");

alert( arr ); // "Я", "вивчаю", "складну", "мову", "JavaScript"
```

````smart header="Від'ємні індекси дозволено"
В цьому і в інших методах масиву допускаються від'ємні індекси. Вони визначають позицію з кінця масиву, як тут:

```js run
let arr = [1, 2, 5];

// з позиції -1 (перед останнім елементом)
// видалити 0 елементів,
// потім вставити 3 та 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```
````

### slice

Метод [arr.slice](mdn:js/Array/slice) набагато простіший, ніж схожий на нього `arr.splice`.

Його синтаксис:

```js
arr.slice([start], [end])
```

Він повертає новий масив копіюючи до нього всі елементи з позиції `start` до позиції `end` (не включаючи саму `end`). Обидві позиції `start` і `end` можуть бути від'ємними. В такому випадку відлік буде здійснюватись з кінця масиву.

Це схоже на рядковий метод `str.slice`, але замість підрядків він повертає підмасиви.

Наприклад:

```js run
let arr = ["т", "е", "с", "т"];

alert( arr.slice(1, 3) ); // е,с (копіює з 1 до 3)

alert( arr.slice(-2) ); // с,т (копіює з -2 до кінця)
```

Можливо визвати `slice` і взагалі без аргументів: `arr.slice()` створює копію масиву `arr`. Це часто використовують, щоб створити копію масиву для подальших перетворень, котрі не повинні змінювати вихідний масив.
### concat

Метод [arr.concat](mdn:js/Array/concat) створює новий масив, який включає в себе дані з інших масивів та додаткові значення.

Його синтаксис:

```js
arr.concat(arg1, arg2...)
```

Він приймає будь-яку кількість аргументів, котрі можуть бути як масивами так і простими значеннями.

Результат є новим масивом, що містить елементи з `arr`, а також `arg1`, `arg2` і т.д.

Якщо аргумент `argN` масив, то всі його елементи копіюються. Інакше копіюється сам аргумент.

Наприклад:

```js run
let arr = [1, 2];

// створити масив з: arr і [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// створити масив з: arr і [3,4] і [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// створити масив з: arr 1 [3,4], потім додати значення 5 і 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

Як правило, він копіює тільки елементи з масивів. Інші об'єкти, навіть якщо вони виглядають як масиви, додаються як є:

```js run
let arr = [1, 2];

let arrayLike = {
  0: "щось",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

...Але якщо об'єкт має спеціальну властивість `Symbol.isConcatSpreadable` , то він обробляється `concat` як масив: замість нього додається його значення.

```js run
let arr = [1, 2];

let arrayLike = {
  0: "щось",
  1: "ще",
*!*
  [Symbol.isConcatSpreadable]: true,
*/!*
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,щось,ще
```

## Перебір: forEach

Метод [arr.forEach](mdn:js/Array/forEach) дозволяє запускати функцію для кожного елемента масиву.

Його синтаксис:
```js
arr.forEach(function(item, index, array) {
  // ... робить щось з item
});
```

Наприклад, цей код виводить на екран кожен елемент масиву:

```js run
// Виклик alert для кожного елемента
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
```

А цей до того ж розповість і про свою позицію в масиві:

```js run
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} має позицію ${index} в ${array}`);
});
```

Результат функції (якщо вона взагалі щось повертає) відкидається і ігнорується.


## Пошук в масиві
Тепер ми розлянемо методи, котрі допоможуть нам знайти що-небудь в масиві.

### indexOf/lastIndexOf і includes
Методи [arr.indexOf](mdn:js/Array/indexOf), [arr.lastIndexOf](mdn:js/Array/lastIndexOf) і [arr.includes](mdn:js/Array/includes) мають однаковий синтаксис і роблять по суті те ж саме, що і їх рядкові аналоги, але працюють з елементами замість символів:

- `arr.indexOf(item, from)` -- шукає `item` починаючи з індексу `from`, і повертає індекс, на якому було знайдено шуканий елемент, інакше `-1`.
- `arr.lastIndexOf(item, from)` -- те ж саме, але шукає справа наліво.
- `arr.includes(item, from)` -- шукає `item` починаючи з індексу `from`, повертає `true`, якщо знайдено.

Наприклад:

```js run
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```

Зверніть увагу що методи використовують суворе порівняння `===`. Таким чином, якщо ми шукаємо `false`, він знаходить саме `false`, а не нуль.

Якщо ми хочемо перевірити наявність елемента, і немає необхідності знати його точний індекс, тоді надаємо перевагу `arr.includes`.

Крім того, дуже незначною відмінністю `includes` є те, що він правильно обробляє `NaN`, на відміну від `indexOf/lastIndexOf`:

```js run
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (повинен бути 0, але === перевірка на рівність не працює для NaN)
alert( arr.includes(NaN) );// true (вірно)
```

### find і findIndex

Уявіть, що у нас є масив об'єктів. Як ми знайдемо об'єкт за конкретною умовою?

Тут нам допоможе метод [arr.find(fn)](mdn:js/Array/find).

Ось його синтаксис:
```js
let result = arr.find(function(item, index, array) {
  // якщо true, то повертається поточний елемент і перебір переривається
  // якщо всі ітерації виявились виявились хибними, то повертається undefined
});
```

Функція викликається для елементів масиву, одного за іншим:

- `item` черговий елемент.
- `index` його індекс.
- `array` сам масив.

Якщо функція повертає `true`, то пошук зупиняється і повертається `item`. Якщо нічого не знайдено, то повертається `undefined`.

Наприклад, в нас є масив користувачів, кожен з яких має по полю `id` і `name`. Спробуємо знайти того, хто має `id == 1`:

```js run
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```

В дійсності масиви об'єктів - звичайна річ, тому метод `find` вкрай корисний.

Зверніть увагу що в цьому прикладі ми надаємо `find` функцію `item => item.id == 1` з одним аргументом. Це типово, додаткові аргументи для цієї функції використовуються рідко.

Метод [arr.findIndex](mdn:js/Array/findIndex) по суті, те ж саме, але повертає індекс, на якому був знайдений елемент, а не сам елемент, і `-1` якщо нічого не знайдено.

### filter

Метод `find` шукає один (перший-ліпший) елемент, на якому функція-колбек поверне `true`.

На той випадок, якщо знайдених елементів може бути багато, передбачений метод [arr.filter(fn)](mdn:js/Array/filter).

Синтаксис цього методу схожий з `find`, але `filter` повертає масив з усіх відповідних елементів:

```js
let results = arr.filter(function(item, index, array) {
  // якщо true - елемент додається до результату, і перебір продовжується
  // повертається пустий масив в випадку, якщо нічого не знайдено
});
```

Наприклад:

```js run
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// повертає масив, який складається з перших двох користувачів
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

## Перетворення масивів

Перейдемо до методів перетворення і упорядкування масиву.

### map

Метод [arr.map](mdn:js/Array/map) - один із найбільш корисних і часто використовуваних.

Він викликає функцію для кожного елемента масиву і повертає масив результатів виконання цієї функції.

Його синтаксис:

```js
let result = arr.map(function(item, index, array) {
  // повертає нове значення замість елемента
});
```

Наприклад, тут ми перетворимо кожен елемент в його довжину:

```js run
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

### sort(fn)

Виклик [arr.sort()](mdn:js/Array/sort) сортує масив "на місці", змінюючи в ньому порядок елементів.

Він повертає відсортований масив, але зазвичай значення, що повертається, ігнорується, оскільки  `arr` сам модифікується.

Наприклад:

```js run
let arr = [ 1, 2, 15 ];

// метод сортує вміст arr 
arr.sort();

alert( arr );  // *!*1, 15, 2*/!*
```

Не помітили нічого дивного в цьому прикладі?

Порядок став `1, 15, 2`. Це невірно! Але чому?

**За замовчуванням елементи сортуються як рядки.**

Буквально, всі елементи перетворюються в рядки при порівнянні. Для рядків застосовується лексикографічний порядок, тому виходить, що `"2" > "15"`.

Для того, щоб використовувати власний порядок сортування, нам потрібно надати функцію як аргумент для `arr.sort()`.

Функція повинна для пари довільних значень повертати:
```js
function compare(a, b) {
  if (a > b) return 1; // якщо перше значення більше другого
  if (a == b) return 0; // якщо рівні
  if (a < b) return -1; // якщо перше значення менше другого
}
```

Наприклад, для сортування чисел:

```js run
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

*!*
arr.sort(compareNumeric);
*/!*

alert(arr);  // *!*1, 2, 15*/!*
```

Тепер все працює як потрібно.
Давайте зупинимося і подумаємо, що ж відбувається. Масив `arr` може бути масивом чого завгодно, вірно? Він може містити числа, рядки, об'єкти або ще щось. Ми маємо набір "якихось елементів". Щоб його посортувати, нам потрібна "функція", яка знає, як порівнювати ці елементи. За замовчуванням елементи сортуються як рядки.

Метод `arr.sort(fn)` реалізує загальний алгоритм сортування. Нам не потрібно піклуватися про те, як він працює всередині (в більшості випадків це оптимізоване [quicksort](https://uk.wikipedia.org/wiki/Швидке_сортування)). Воно проходиться по масиву, порівнює його елементи за допомогою наданої йому функції і змінює їх порядок розташування. Все, що залишається нам, це надати функцію `fn` яка порівнює елементи.

До речі, якщо ми коли-небудь захочемо дізнатися, які елементи порівнюються -- ніщо не заважає нам вивести їх на екран:

```js run
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
});
```

В процесі роботи алгоритм може порівнювати елемент з іншими по декілька разів, але він намагається зробити якомога менше порівнянь.

````smart header="Порівняльна функція може повернути будь-яке число"
Насправді, функція порівняння потрібна тільки для того, щоб повернути додатне число і показати "більше", або від'ємне, щоб показати "менше".

Це дозволяє писати більш короткі функції:

```js run
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // *!*1, 2, 15*/!*
```
````

````smart header="Стрілкові функції рулять!"
Пам'ятаєте [стрілкові функції](info:arrow-functions-basics)? Ми їх можемо використати тут для кращого сортування, працює так само, а писати менше:

```js
arr.sort( (a, b) => a - b );
```

Працює ідентично до довгої версії, котра наведена вище.
````

````smart header="Використання `localeCompare` для рядків"
Пам'ятаєте [алгоритм](info:string#correct-comparisons) порівняння рядків? Він за замовчуванням порівнює літери за їх кодом.

Для багатьох абеток краще використовувати метод `str.localeCompare`, щоб правильно відсортовувати за абеткою, наприклад, такий символ як `Ö`.

Наприклад, давайте посортуємо кілька країн за Німецькою абеткою:

```js run
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (неправильно)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (тепер посортовано як треба!)
```
````

### reverse

Метод [arr.reverse](mdn:js/Array/reverse) змінює порядок розміщення елементів в `arr` на протилежний.

Наприклад:

```js run
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

Він також повертає масив `arr` з зміненим порядком елементів.

### split і join

Ось ситуація з реального життя. Ми пишемо додаток для обміну повідомленнями, і відвідувач вводить імена тих, кому має відправити повідомлення, через кому: `John, Pete, Mary`. Але для нас масив імен був би набагато зручнішим, ніж один рядок. Як його отримати?

Метод [str.split(delim)](mdn:js/String/split) якраз те, що нам потрібно. Він розбиває рядок на елементи масиву за вказаним роздільником `delim`.

В нижченаведеному випадку ми розбиваємо рядок за комою з пробілом:

```js run
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `Повідомлення для ${name}.` ); // Повідомлення для Bilbo  (і т.д.)
}
```

Метод `split` має другий умовний числовий аргумент -- обмеження на кількість елементів в масиві. Якщо їх більше, ніж вказано, то залишок масива буде пропущено. Хоча на практиці це використовується рідко:

```js run
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```

````smart header="Розщеплення рядка на літери"
Виклик `split(s)` з пустим `s` буде розщеплювати рядок на літери:

```js run
let str = "cqcqcqdx";

alert( str.split('') ); // c,q,c,q,c,q,d,x
```
````

Виклик [arr.join(glue)](mdn:js/Array/join) є протилежним до `split`.Він створює рядок з елементів `arr` з'єднаних за допомогою `glue` між собою.

Наприклад:

```js run
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // зліплюємо масив в рядок за допомогою ;

alert( str ); // Bilbo;Gandalf;Nazgul
```

### reduce/reduceRight

Якщо нам потрібно перебрати масив -- ми можемо використати `forEach`, `for` або `for..of`.

Якщо нам потрібно перебирати і повертати дані для кожного елемента -- ми можемо скористатись `map`.

Методи [arr.reduce](mdn:js/Array/reduce) і [arr.reduceRight](mdn:js/Array/reduceRight) схожі на вищезазначені методи, але вони більш складні. Вони використовуються для обчислення будь-якого єдиного значення на основі всього масиву.


Синтаксис:

```js
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```

Функція застосовується по черзі до всих елементів масиву і "переносить" свій результат на слідуючий виклик.

Аргументи:

- `accumulator` -- результат попереднього виклика цієї функції, дорівнює `initial` при першому виклику (якщо переданий `initial`).
- `item` -- черговий елемент масива.
- `index` -- його індекс.
- `array` -- сам масив.

Під час застосування функції, результат попереднього виклику функції передається до наступного в якості першого аргументу.

Так, перший аргумент є по суті накопичувачем, який зберігає об'єднаний результат усіх попередніх виконань функції і врешті-решт він стає результатом `reduce`.

Звучить складно?

Цей метод найпростіше зрозуміти на прикладі.

Тут ми отримаємо суму усіх елементів масиву всього одним рядком:

```js run
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

Функція передана до `reduce` використовує 2 аргумента, що досить типово.

Давайте розберемо детальніше, як це працює.

1. При першому запуску `sum` дорівнює `initial` (останній аргумент `reduce`), тобто `0`, а `current` -- перший елемент масиву, дорівнює `1`. Таким чином, результат функції дорівнює `1`.
2. При другому запуску, `sum = 1`, ми додаємо до нього другий елемент масиву (`2`).
3. При третьому запуску, `sum = 3` ми додаємо до нього слідуючий елемент масиву і т.д.

Потік обчислень:

![](reduce.svg)

Або у вигляді таблиці, де кожен рядок являє собою виклик функції на наступний елемент масиву:

|   |`sum`|`current`|result|
|---|-----|---------|---------|
|перший виклик|`0`|`1`|`1`|
|другий виклик|`1`|`2`|`3`|
|третій виклик|`3`|`3`|`6`|
|четвертий виклик|`6`|`4`|`10`|
|п'ятий виклик|`10`|`5`|`15`|

Тут виразно видно, як результат попереднього виклику передається в перший аргумент наступного.

Ми також можемо опустити початкове значення:

```js run
let arr = [1, 2, 3, 4, 5];

// прибрано початкове значення з reduce (немає 0 в кінці)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
```

Результат однаковий. Це тому, що якщо немає значення `initial`, тоді `reduce` приймає перший елемент масиву в якості початкового значення і починає ітерацію з 2-го елемента.

Таблиця розрахунку така ж, як зазначено вище, але без першого рядка.

Але таке використання вимагає обережності. Якщо масив порожній, тоді виклик `reduce` без початкового значення видає помилку.

Ось приклад:

```js run
let arr = [];

// Error: Reduce of empty array with no initial value
// якщо б існувало початкове значення, reduce повернув би його для порожнього масиву arr.
arr.reduce((sum, current) => sum + current);
```

Тому рекомендується завжди вказувати початкове значення.

Метод [arr.reduceRight](mdn:js/Array/reduceRight) робить те ж саме, але проходить по масиву справа наліво.


## Array.isArray

Масиви не утворюють окремий тип мови. Вони засновані на об'єктах.

Тому `typeof` не може відрізнити простий об'єкт від масиву:

```js run
alert(typeof {}); // object
alert(typeof []); // також object
```

...Але масиви використовуються настільки часто, що для цього вигадали спеціальний метод : [Array.isArray(value)](mdn:js/Array/isArray). Він повертає `true`, якщо `value` масив, і `false`, якщо ні.

```js run
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
```

## Більшість методів підтримують "thisArg"

Майже всі методи масиву, які викликають функції -- такі як `find`, `filter`, `map`, за виключенням методу `sort`, приймають необов'язковий параметр `thisArg`.

Цей параметр не пояснювався в вищевикладених розділах, оскільки він рідко використовується, але для повного розуміння теми ми зобов'язані його розглянути.

Ось повний синтаксис цих методів:

```js
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - це необов'язковий останній аргумент
```

Значення параметра `thisArg` стає `this` для `func`.

Наприклад, ось тут ми використовуємо метод об'єкту `army` як фільтр, і `thisArg` передає йому контекст :

```js run
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

*!*
// знайти користувачів, для котрих army.canJoin повертає true
let soldiers = users.filter(army.canJoin, army);
*/!*

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

Якщо б ми на вищенаведеному прикладі використовували просто `users.filter(army.canJoin)`, то виклик `army.canJoin` був би в режимі окремої функції `this=undefined`, миттєво приводячи до помилки.

Виклик `users.filter(army.canJoin, army)` може бути замінений на `users.filter(user => army.canJoin(user))`, який робить те ж саме. Останній запис використовується навіть частіше, оскільки стрілочна функція більш наглядна.

## Висновок

Шпаргалка по методах масиву:

- Для додавання/видалення елементів:
  - `push(...items)` -- додає елемент в кінець,
  - `pop()` -- видобуває елемент з кінця,
  - `shift()` -- видобуває елемент з початку,
  - `unshift(...items)` -- додає елемент на початок.
  - `splice(pos, deleteCount, ...items)` -- починаючи з індексу `pos` видаляє `deleteCount` елементів і вставляє `items`.
  - `slice(start, end)` -- створює новий масив, копіюючи в нього елементи з позиції `start` до `end` (не включаючи `end`).
  - `concat(...items)` -- повертає новий масив: копіює всіх членів поточного масиву і додає до нього `items`. Якщо якийсь з `items` є масивом, тоді беруться його елементи.

- Для пошуку серед елементів:
  - `indexOf/lastIndexOf(item, pos)` -- шукає `item` починаючи з позиції `pos`, і повертає його індекс або `-1`, якщо нічого не знайдено.
  - `includes(value)` -- повертає `true` якщо в масиві є елемент `value`, інакше  `false`.
  - `find/filter(func)` -- фільтрує елементи через функцію і віддає перше/всі значення, при проходженні яких через функцію повертається `true`.
  - `findIndex` схожий на `find`, але повертає індекс замість значення.

- Для перебору елементів:
  - `forEach(func)` -- викликає `func` для кожного елементу, нічого не повертаючи.

- Для перетворення масиву:
  - `map(func)` -- створює новий масив за результатами виклику `func` для кожного елементу.
  - `sort(func)` -- сортує масив "на місці", а потім повертає його.
  - `reverse()` -- "на місці" змінює послідовність елементів на протилежну і повертає змінений масив.
  - `split/join` -- перетворює рядок в масив і навпаки.
  - `reduce(func, initial)` -- обчислює одне значення на основі всього масиву, викликаючи `func` для кожного елемента і передаючи проміжний результат між викликами.

- Додатково:
  - `Array.isArray(arr)` перевіряє, чи є `arr` масивом.

Зверніть увагу, що методи `sort`, `reverse` і `splice` змінюють вихідний масив.

Вивчених нами методів досить в 99% випадків, але існують і інші:

- [arr.some(fn)](mdn:js/Array/some)/[arr.every(fn)](mdn:js/Array/every) перевіряє масив.

  Функція `fn` викликається для кожного елемента масиву аналогічно `map`. Якщо будь-які/всі результати викликів є `true`, то метод повертає `true`, інакше `false`.

- [arr.fill(value, start, end)](mdn:js/Array/fill) -- заповнює масив повторюваними `value` починаючи з індексу `start` до `end`.

- [arr.copyWithin(target, start, end)](mdn:js/Array/copyWithin) -- копіює свої елементи, починаючи з `start` і закінчуючи `end` в власну позицію `target` (перезаписує існуючі).

Повний список є в довіднику [manual](mdn:js/Array).

На перший погляд може здатися, що існує дуже багато різних методів, які досить складно запам'ятати. Але це набагато простіше, ніж здається.

Уважно вивчіть шпаргалку, наведену вище, а потім, щоб попрактикуватися, вирішіть завдання, запропоновані в цьому розділі. Так ви отримаєте необхідний досвід в правильному використанні методів масиву.

Кожен раз, коли вам буде необхідно зробити що-небудь з масивом, а ви не знаєте, як це зробити -- приходьте сюди, дивіться на таблицю і шукайте вірний метод. Приклади допоможуть вам все зробити вірно, і незабаром ви швидко запам'ятаєте методи без особливих зусиль.
