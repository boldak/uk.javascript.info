
# Map і Set

Ми вже знаємо наступні складні структури даних:

- Об'єкти для зберігання іменованих колекцій.
- Масиви для зберігання впорядкованих колекцій.

Але цих структур не завжди достатньо для вирішення повсякденних завдань. Тому також існують `Map` і `Set`

## Map

[Map](mdn:js/Map) це колекція ключ/значення, як і `Object`. Але головна різниця в тому, що `Map` дозволяє використовувати ключі будь-якого типу.

Методи і властивості:

- `new Map()` -- створює об'єкт `Map`.
- `map.set(key, value)` -- задає значення `value` по ключу `key`.
- `map.get(key)` -- повертає значення по ключу або `undefined` якщо ключ `key` відсутній в колекції.
- `map.has(key)` -- повертає `true` якщо ключ `key` існує і `false` якщо ні.
- `map.delete(key)` -- видаляє елемент по ключу `key`.
- `map.clear()` -- очищує всю колекцію.
- `map.size` -- повертає кількість усіх елементів які знаходяться у колекції.

Наприклад:

```js run
let map = new Map();

map.set('1', 'str1');   // рядок у якості ключа
map.set(1, 'num1');     // цифра у якості ключа
map.set(true, 'bool1'); // boolean-значення в якості ключа

// пам'ятаєте звичайний Object? він конвертував ключі в рядки
// Map зберігає тип ключа, тому ми отримуємо два різні значення:
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
```

Очевидно що, на відміну від об'єктів, ключі не ковертуються в рядки. Тому можна використовувати будь-які типи даних для ключів.


```smart header="`map[key]` -- неправильний варіант використання `Map`"
Конструкція `map[key] = 2` працюватиме, але вона буде трактувати `map` як звичайний JavaScript-об’єкт. Тому для `map` застосуються відповідні обмеження (відсутність об'єктних ключів тощо)

Отже, ми повинні використовувати методи `set`, `get` тощо.
```



**Map також може використовувати об'єкти в якості ключів.**

Наприклад:

```js run
let john = { name: "John" };

// давайте збережемо кількість відвідувань для кожного користувача
let visitsCountMap = new Map();

// об'єкт john це ключ для значення в об'єкті map
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123
```

Використання об'єктів в якості ключів є одною з найважливіших та найбільш використовуваних особливостей `Map`. Для рядкових ключів `Object` підійде, але для ключів-об'єктів його вже не застосуєш.

Спробуємо замінити `Map` на `Object`:

```js run
let john = { name: "John" };

let visitsCountObj = {}; // спробуємо використати об'єкт

visitsCountObj[john] = 123; // спробуємо використати об'єкт john як ключ

*!*
// Ось що ми отримали!
alert( visitsCountObj["[object Object]"] ); // 123
*/!*
```

Оскільки `visitsCountObj` це об'єкт, то всі ключі він автоматично конвертує в рядок, в результаті ми отримаємо рядковий ключ `"[object Object]"`. А це не те, що ми хочемо отримати.

```smart header="Як `Map` порівнює ключі"
Для порівняння ключів, об'єкт `Map` використовує алгоритм [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero). Це майже таке саме порівняння як і `===`, але різниця полягає в тому, що `NaN` вважається рівним `NaN`. Тож `NaN` може бути використаний і як ключ.

Цей алгоритм не може бути замінений або модифікований
```

````smart header="Ланцюжок викликів"
Кожен виклик `map.set` повертає об'єкт `map`, тому ми можемо об'єднати виклики у ланцюжок:

```js
map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
```
````


## Ітерації по Map

Для ітерування по `map` існує 3 методи:

- `map.keys()` -- повертає ітерабельні значення по ключу,
- `map.values()` -- повертає ітерабельні значення по значенню,
- `map.entries()` -- повертає ітерабельні значення для пар виду `[ключ, значення]`, цей варіант за замовчуванням використовується в `for..of`.

Наприклад:

```js run
let recipeMap = new Map([
  ['огірок', 500],
  ['помідор', 350],
  ['цибуля',    50]
]);

// ітерування по ключам (vegetables)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // огірок, помідор, цибуля
}

// ітерування по значенням (amounts)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// ітерування по елементам в форматі [key, value]
for (let entry of recipeMap) { // те ж саме, що і recipeMap.entries()
  alert(entry); // огірок, 500 (і так далі)
}
```

```smart header="Використовується порядок вставки"
Навідміну від звичайних об'єктів `Object, у `Map` використовується ітерування в тому ж порядку, в якому відбувалося додавання елементів.
```

Окрім цього, `Map` має вбудований метод `forEach`, схожий з вбудованим методом масивів `Array`:

```js
// виконуємо функцію для кожної пари (ключ, значення)
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // огірок: 500 і т.д.
});
```

## Object.entries: Map з Object

Під час створення `Map` ми можемо вказати масив (або інший ітерабельний об'єкт) з парами ключ-значення для ініціалізації:

```js run
// масив пар [ключ, значення]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
```

Якщо у нас вже є звичайний об'єкт і ми хочемо створити `Map` з нього, то нам допоможе вбудований метод [Object.entries(obj)](mdn:js/Object/entries), який поверне масив пар ключ/значення для нього у потрібному форматі.

Таким чином ми можемо створити `Map` із звичайного об'єкту:

```js run
let obj = {
  name: "John",
  age: 30
};

*!*
let map = new Map(Object.entries(obj));
*/!*

alert( map.get('name') ); // John
```

Тут `Object.entries` повертає масив пар ключ/значення: `[ ["name","John"], ["age", 30] ]`. Це те, що потрібно для створення `Map`.


## Object.fromEntries: Object з Map

Тільки що ми побачили як створити `Map` із звичайного об'єкту використовуючи `Object.entries(obj)`.

Існує метод `Object.fromEntries`, що робить все навпаки: отримавши масив пар виду `[ключ, значення]`, він створює з них об'єкт:

```js run
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
```

Ми можемо використовувати `Object.fromEntries` для того, щоб отримати звичайний об'єкт з `Map`.

Наприклад, ми зберігаємо дані в `Map`, але нам потрібно передати його в сторонній код, який очікує звичайний об'єкт.

Ось як ми можемо це зробити:

```js run
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

*!*
let obj = Object.fromEntries(map.entries()); // робимо звичайний об'єкт (*)
*/!*

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```

Виклик `map.entries()` повертає масив пар ключ/значення в потрібному для `Object.fromEntries` форматі.

Ми можемо записати рядок `(*)` ще коротше:
```js
let obj = Object.fromEntries(map); // прибрати .entries()
```

Цей код робить те саме, бо `Object.fromEntries` очікує ітерабельний об'єкт в якості аргумента. І це не обов'язково повинен бути масив. А ітерування по `map` повертає пари ключ/значення як і `map.entries()`. В результаті ми отримуємо звичайний об'єкт з тими ж парами ключ/значення.

## Set

Об'єкт `Set` -- особливий тип колекції "множина значень" (без ключів), де кожне значення з'являється лише один раз.
Його основні методи:

- `new Set(iterable)` -- створює `set`, і якщо як аргумент `iterable` був використаний ітерабельний об'єкт (зазвичай це масив), копіює його значення в новий `Set`.
- `set.add(value)` -- додає значення (якщо воно вже є, то нічого не робить), повертає той самий об'єкт `set`.
- `set.delete(value)` -- видаляє значення, повертає `true` якщо `value` існувало в множині у момент виклику, інакше повертає `false`.
- `set.has(value)` -- повертає `true` якщо значення існує в множені, інакше повертає `false`.
- `set.clear()` -- видаляє усі наявні значення.
- `set.size` -- повертає кількість елементів множини.

Основна особливість полягає в тому, що при повторних викликах `set.add(value)` з тим самим значенням нічого не відбувається. Саме тому кожне значення з'являтиметься в `Set` лише один раз.

Наприклад, ми очікуємо відвідувачів і нам потрібно скласти їх список. Але повторні візити не повинні призводити до створення дубліката. Кожен відвідувач повинен з'явитися в списку лише один раз.

`Set` те, що нам для цього потрібно:

```js run
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// рахуємо відвідувачів, деякі приходять декілька разів
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set зберігає лише 3 унікальні значення
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // John (потім Pete і Mary)
}
```

Альтернативою до `Set` може бути масив для зберігання відвідувачів та код для перевірки на дублікати за допомогою [arr.find](mdn:js/Array/find). Але в такому разі продуктивність буде гірша, оскільки цей метод проходить увесь масив для перевірки наявності елемента. `Set` краще оптимізований для додавання і автоматично перевіряє на унікальність.

## Ітерування по Set
Для ітерування по `Set` ми можемо використовувати як `for..of` так і `forEach`:

```js run
let set = new Set(["апельсин", "яблуко", "банан"]);

for (let value of set) alert(value);

// теж саме з forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```

Зверніть увагу на кумедну річ. Функція зворотного виклику, передана в `forEach` має 3 аргументи: значення `value`, потім *знову те саме значення* `valueAgain`, і тільки потім цільовий об'єкт. І це дійсно так: значення з'являється у списку аргументів два рази.

І це не випадково, оскільки це потрібно для сумісності з  `Map`, який має колбек з 3 аргументами. Виглядає досить дивно, але в деяких випадках дозволить легко замінити `Map` на `Set` і навпаки. 

`Set` має такі самі вбудовані методи для ітерування:

- `set.keys()` -- повертає ітерабельний об'єкт для значень,
- `set.values()` -- виконує те саме, що й `set.keys()`, присутній для сумісності з `Map`,
- `set.entries()` -- повертає ітерабельний об'єкт для пар `[значення, значення]`, присутній для сумісності з `Map`.

## Підсумок

`Map` -- колекція пар ключ/значення.

Методи і властивості:

- `new Map([iterable])` -- створює об'єкт `map`, для ініціалізації можна вказати ітерабельний об'єкт `iterable` (зазвичай масив), що складається з пар `[ключ,значення]`.
- `map.set(key, value)` -- записує значення `value` по ключу `key`.
- `map.get(key)` -- повертає значення по ключу або `undefined` якщо ключ `key` відсутній.
- `map.has(key)` -- повертає `true` якщо ключ `key` присутній в колекції та інакше `false`.
- `map.delete(key)` -- видаляє елемент по ключу `key`.
- `map.clear()` -- очищує колекцію від всіх елементів.
- `map.size` -- повертає кількість елементів.

Відмінності від звичайного об'єкта `Object`:

- В якості ключа можна використовувати будь-що, в тому числі й об'єкти.
- Має додаткові методи, властивість `size`.

`Set` -- колекція унікальних значень, "множина".

Методи і властивості:

- `new Set([iterable])` -- створює `Set`, для ініціалізації можна вказати ітерабельний об'єкт `iterable` (зазвичай масив).
- `set.add(value)` -- додає значення `value` (або нічого не робить,якщо воно вже присутнє), повертає той самий об'єкт `set`.
- `set.delete(value)` -- видаляє значення `value`, повертає `true` якщо `value` присутнє у момент виклику, інакше `false`.
- `set.has(value)` -- повертає `true` якщо значення присутнє, інакше `false`.
- `set.clear()` -- очищує колекцію від усіх елементів.
- `set.size` -- повертає кількість елементів.

Ітерування по `Map` та `Set` завжди виконується в порядку їх додавання, тому не можна сказати, що це невпорядковані колекції, але змінити порядок або отримати елемент, використовуючи його номер, ми не можемо.
