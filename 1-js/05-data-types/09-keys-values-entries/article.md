
# Об'єкт ключ-значення, записи

Давайте відійдемо від окремих структур даних і поговоримо про ітерації над ними.

У попередньому розділі ми бачили методи map.keys(), map.values(), map.entries().

Ці методи є загальними, існує спільна згода використовувати їх для структур даних. Якщо ми коли-небудь створимо власну структуру даних, ми також повинні їх реалізувати.

Вони підтримуються для:

Map
Set
Array

Звичайні об'єкти також підтримують подібні методи, але синтаксис трохи інший.

# Об'єкт.ключі, значення, записи

Для простих об'єктів доступні наступні методи:

Object.keys(obj) -- повертає масив ключів.
Object.values(obj) -- повертає масив значень.
Object.entries(obj) -- повертає масив [key, value] пар.

Зверніть увагу на відмінності (порівняно з картою, наприклад):

Мапа	Об'єкт
Виклик синтаксису	map.keys()	Object.keys(obj), але не obj.keys()
Повертає	ітерабельний	"справжній" Масив
Перша відмінність полягає в тому, що ми повинні викликати Object.keys (obj), а не obj.keys ().

Чому так? Основна причина - гнучкість. Пам'ятайте, що об'єкти є базою всіх складних структур у JavaScript. Таким чином, у нас може бути власний об'єкт на зразок data, який реалізує власний методdata.values(). І ми все ще можемо звернутися до "Object.values(data)" на ньому.

Друга відмінність полягає в тому, що методи Object. * Повертають "реальні" об'єкти масиву, а не просто ітерабельні. Це в основному з історичних причин.

Наприклад:

let user = {
  name: "John",
  age: 30
};
Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]
Ось приклад використання Object.values для переходу на значення властивостей:

let user = {
  name: "John",
  age: 30
};

// циклічне значення
for (let value of Object.values(user)) {
  alert(value); // Джону, тоді 30 років
}
`` warn header =" Object.keys / величини / записи ігнорують символьні властивості " Як і цикл for..in`, ці методи ігнорують властивості, які використовують` Symbol (...) `як ключі.

Зазвичай це зручно. Але якщо ми також хочемо символічних ключів, то існує окремий метод [Object.getOwnPropertySymbols] (mdn: js / Object / getOwnPropertySymbols), який повертає масив лише символічних ключів. Також існує метод [Reflect.ownKeys (obj)] (mdn: js / Reflect / ownKeys), який повертає * усі * ключі.



## Перетворення об’єктів

Об'єктам бракує багатьох методів, які існують для масивів, наприклад `карта`,` фільтр` та інші.

Якщо ми хочемо їх застосувати, тоді ми можемо використовувати `Object.entries` за пунктом` Object.fromEntries`:

1. Використовуйте `Object.entries (obj)`, щоб отримати масив пар ключів / значень з `obj`.
2. Використовуйте методи масиву для цього масиву, наприклад `карта`.
3. Використовуйте "Object.fromEntries (масив)" на отриманому масиві, щоб повернути його назад в об'єкт.

Наприклад, у нас є об'єкт із цінами, і ми хотіли б їх подвоїти:

```js run
let prices = {
  banana: 1, //банан: 1//
  orange: 2, //апельсин: 2//
  meat: 4, //м'ясо: 4//
};

*!*
let doublePrices = Object.fromEntries(
  // перетворити в масив, карту, а потім із fromEntries повертає об'єкт
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);
*/!*

alert(doublePrices.meat); // 8

Це може виглядати важко з першого погляду, але стає зрозумілим легко після того, як ви використовуєте його один або два рази. Ми можемо зробити потужні ланцюги перетворень таким чином. 
